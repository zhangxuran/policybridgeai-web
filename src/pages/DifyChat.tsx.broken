import { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '@/contexts/AuthContext';
import { supabase } from '@/lib/supabase';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { Textarea } from '@/components/ui/textarea';
import { Checkbox } from '@/components/ui/checkbox';
import { Avatar, AvatarFallback } from '@/components/ui/avatar';
import { toast } from 'sonner';
import { Send, Upload, Loader2, MessageSquare, Trash2, ArrowLeft, User, Scale, X, FileText, File, Download, ExternalLink } from 'lucide-react';
import Navbar from '@/components/Navbar';
import ConfirmDialog from '@/components/ConfirmDialog';
import { UpgradeDialog } from '@/components/UpgradeDialog';
import { checkFeatureAccess } from '@/lib/permissions';
import { stripMarkdown } from '@/lib/markdownUtils';

interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  isStreaming?: boolean;
  isThinking?: boolean;
  attachedFile?: {
    name: string;
    type: 'pdf' | 'word' | 'txt';
  };
}

interface Conversation {
  id: string;
  title: string;
  created_at: string;
  dify_conversation_id?: string;
}

interface DifyChatRequestBody {
  query: string;
  user_id: string;
  conversation_id?: string;
  files?: Array<{
    type: string;
    transfer_method: string;
    upload_file_id: string;
  }>;
}

interface UploadedFile {
  id: string;
  name: string;
}

// Thinking process messages that cycle during AI response
const THINKING_MESSAGES = [
  'æ­£åœ¨ç†è§£æ‚¨çš„é—®é¢˜...',
  'æ­£åœ¨è°ƒç”¨çŸ¥è¯†åº“...',
  'æ­£åœ¨åˆ†æç›¸å…³æ³•è§„...',
  'æ­£åœ¨ç”Ÿæˆå›å¤...',
  'å³å°†å®Œæˆ...'
];

// Special message for identity confirmation (first message)
const IDENTITY_CONFIRMATION_MESSAGE = 'æ­£åœ¨è¿›è¡Œèº«ä»½ç¡®è®¤';

// Helper function to get file type from filename
const getFileType = (filename: string): 'pdf' | 'word' | 'txt' => {
  const extension = filename.split('.').pop()?.toLowerCase();
  if (extension === 'pdf') return 'pdf';
  if (extension === 'doc' || extension === 'docx') return 'word';
  return 'txt';
};

// File icon component
const FileIcon = ({ type }: { type: 'pdf' | 'word' | 'txt' }) => {
  const getIconStyle = () => {
    switch (type) {
      case 'pdf':
        return 'text-red-500';
      case 'word':
        return 'text-blue-500';
      case 'txt':
        return 'text-gray-500';
    }
  };

  const getLabel = () => {
    switch (type) {
      case 'pdf':
        return 'PDF';
      case 'word':
        return 'Word';
      case 'txt':
        return 'TXT';
    }
  };

  return (
    <div className="flex items-center gap-1.5">
      <FileText className={`h-4 w-4 ${getIconStyle()}`} />
      <span className="text-xs font-medium text-white/90">{getLabel()}</span>
    </div>
  );
};

// Parse message content and convert links to clickable elements
// This function now strips Markdown formatting for assistant messages
const parseMessageContent = (content: string, isUserMessage: boolean = false): React.ReactNode[] => {
  // Strip Markdown formatting from assistant messages to show plain text
  const processedContent = isUserMessage ? content : stripMarkdown(content);
  
  const elements: React.ReactNode[] = [];
  
  // Regex patterns
  const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
  const urlRegex = /(https?:\/\/[^\s]+)/g;
  
  // Track processed ranges to avoid double-processing
  const processedRanges: Array<{start: number, end: number}> = [];
  
  // First, find all markdown links
  let match;
  const markdownMatches: Array<{start: number, end: number, text: string, url: string}> = [];
  
  while ((match = markdownLinkRegex.exec(processedContent)) !== null) {
    markdownMatches.push({
      start: match.index,
      end: match.index + match[0].length,
      text: match[1],
      url: match[2]
    });
  }
  
  // Process content with markdown links
  let lastIndex = 0;
  
  for (const mdMatch of markdownMatches) {
    // Add text before the link
    if (mdMatch.start > lastIndex) {
      const textBefore = processedContent.substring(lastIndex, mdMatch.start);
      elements.push(textBefore);
    }
    
    // Check if it's a file download link
    const isFileLink = /\.(pdf|doc|docx)(\?|$)/i.test(mdMatch.url);
    
    if (isFileLink) {
      // File download button
      elements.push(
        <a
          key={`md-${mdMatch.start}`}
          href={mdMatch.url}
          download
          target="_blank"
          rel="noopener noreferrer"
          className={`inline-flex items-center gap-2 px-3 py-1.5 rounded-lg ${
            isUserMessage 
              ? 'bg-white/20 hover:bg-white/30 text-white' 
              : 'bg-blue-50 hover:bg-blue-100 text-blue-700'
          } transition-colors duration-200 my-1`}
        >
          <Download className="h-4 w-4" />
          <span className="text-sm font-medium">{mdMatch.text}</span>
        </a>
      );
    } else {
      // Regular link
      elements.push(
        <a
          key={`md-${mdMatch.start}`}
          href={mdMatch.url}
          target="_blank"
          rel="noopener noreferrer"
          className={`inline-flex items-center gap-1 underline ${
            isUserMessage 
              ? 'text-white hover:text-blue-100' 
              : 'text-blue-600 hover:text-blue-800'
          }`}
        >
          {mdMatch.text}
          <ExternalLink className="h-3 w-3" />
        </a>
      );
    }
    
    processedRanges.push({ start: mdMatch.start, end: mdMatch.end });
    lastIndex = mdMatch.end;
  }
  
  // Add remaining text and process standalone URLs
  const remainingText = processedContent.substring(lastIndex);
  
  // Process standalone URLs in remaining text
  if (remainingText) {
    let urlLastIndex = 0;
    const urlMatches: Array<{start: number, end: number, url: string}> = [];
    
    while ((match = urlRegex.exec(remainingText)) !== null) {
      // Check if this URL is part of a markdown link we already processed
      const absoluteStart = lastIndex + match.index;
      const absoluteEnd = absoluteStart + match[0].length;
      
      const isInProcessedRange = processedRanges.some(
        range => absoluteStart >= range.start && absoluteEnd <= range.end
      );
      
      if (!isInProcessedRange) {
        urlMatches.push({
          start: match.index,
          end: match.index + match[0].length,
          url: match[0]
        });
      }
    }
    
    // Add text and URLs
    for (const urlMatch of urlMatches) {
      // Add text before URL
      if (urlMatch.start > urlLastIndex) {
        elements.push(remainingText.substring(urlLastIndex, urlMatch.start));
      }
      
      // Check if it's a file link
      const isFileLink = /\.(pdf|doc|docx)(\?|$)/i.test(urlMatch.url);
      
      if (isFileLink) {
        // File download button
        elements.push(
          <a
            key={`url-${lastIndex + urlMatch.start}`}
            href={urlMatch.url}
            download
            target="_blank"
            rel="noopener noreferrer"
            className={`inline-flex items-center gap-2 px-3 py-1.5 rounded-lg ${
              isUserMessage 
                ? 'bg-white/20 hover:bg-white/30 text-white' 
                : 'bg-blue-50 hover:bg-blue-100 text-blue-700'
            } transition-colors duration-200 my-1`}
          >
            <Download className="h-4 w-4" />
            <span className="text-sm font-medium break-all">ä¸‹è½½æ–‡ä»¶</span>
          </a>
        );
      } else {
        // Regular URL link
        elements.push(
          <a
            key={`url-${lastIndex + urlMatch.start}`}
            href={urlMatch.url}
            target="_blank"
            rel="noopener noreferrer"
            className={`inline-flex items-center gap-1 underline break-all ${
              isUserMessage 
                ? 'text-white hover:text-blue-100' 
                : 'text-blue-600 hover:text-blue-800'
            }`}
          >
            {urlMatch.url}
            <ExternalLink className="h-3 w-3 flex-shrink-0" />
          </a>
        );
      }
      
      urlLastIndex = urlMatch.end;
    }
    
    // Add remaining text
    if (urlLastIndex < remainingText.length) {
      elements.push(remainingText.substring(urlLastIndex));
    }
  }
  
  return elements.length > 0 ? elements : [processedContent];
};

export default function DifyChat() {
  const { user } = useAuth();
  const navigate = useNavigate();
  const [input, setInput] = useState('');
  const [messages, setMessages] = useState<Message[]>([]);
  const [loading, setLoading] = useState(false);
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [currentConversationId, setCurrentConversationId] = useState<string | null>(null);
  const [currentDifyConversationId, setCurrentDifyConversationId] = useState<string | null>(null);
  const [selectedConversations, setSelectedConversations] = useState<Set<string>>(new Set());
  const [showBatchDeleteDialog, setShowBatchDeleteDialog] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [conversationToDelete, setConversationToDelete] = useState<string | null>(null);
  const [isInitialLoad, setIsInitialLoad] = useState(true);
  const [thinkingMessageIndex, setThinkingMessageIndex] = useState(0);
  const [isFirstMessage, setIsFirstMessage] = useState(false);
  const [showUpgradeDialog, setShowUpgradeDialog] = useState(false);
  const [uploadingFile, setUploadingFile] = useState(false);
  const [uploadedFile, setUploadedFile] = useState<UploadedFile | null>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const thinkingIntervalRef = useRef<NodeJS.Timeout | null>(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  useEffect(() => {
    if (!user) {
      navigate('/login');
      return;
    }
    loadConversationsAndAutoLoad();
  }, [user, navigate]);

  // Cleanup thinking interval on unmount
  useEffect(() => {
    return () => {
      if (thinkingIntervalRef.current) {
        clearInterval(thinkingIntervalRef.current);
      }
    };
  }, []);

  const startThinkingAnimation = (isFirst: boolean) => {
    setThinkingMessageIndex(0);
    setIsFirstMessage(isFirst);
    
    // Clear any existing interval
    if (thinkingIntervalRef.current) {
      clearInterval(thinkingIntervalRef.current);
    }

    // If it's the first message (identity confirmation), don't start the interval
    if (isFirst) {
      return;
    }

    // Cycle through thinking messages every 5 seconds
    thinkingIntervalRef.current = setInterval(() => {
      setThinkingMessageIndex((prevIndex) => {
        const nextIndex = prevIndex + 1;
        // Stop at the last message "å³å°†å®Œæˆ..."
        if (nextIndex >= THINKING_MESSAGES.length - 1) {
          // Clear the interval when reaching the last message
          if (thinkingIntervalRef.current) {
            clearInterval(thinkingIntervalRef.current);
            thinkingIntervalRef.current = null;
          }
          return THINKING_MESSAGES.length - 1;
        }
        return nextIndex;
      });
    }, 5000);
  };

  const stopThinkingAnimation = () => {
    if (thinkingIntervalRef.current) {
      clearInterval(thinkingIntervalRef.current);
      thinkingIntervalRef.current = null;
    }
    setThinkingMessageIndex(0);
    setIsFirstMessage(false);
  };

  const loadConversationsAndAutoLoad = async () => {
    if (!user) return;

    try {
      const { data, error } = await supabase
        .from('conversations')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false });

      if (error) throw error;
      
      const loadedConversations = data || [];
      setConversations(loadedConversations);

      // Auto-load the most recent conversation on initial load
      if (isInitialLoad && loadedConversations.length > 0) {
        const mostRecentConversation = loadedConversations[0];
        await loadConversation(mostRecentConversation.id);
        setIsInitialLoad(false);
      }
    } catch (error) {
      console.error('Error loading conversations:', error);
    }
  };

  const loadConversations = async () => {
    if (!user) return;

    try {
      const { data, error } = await supabase
        .from('conversations')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false });

      if (error) throw error;
      setConversations(data || []);
    } catch (error) {
      console.error('Error loading conversations:', error);
    }
  };

  const createNewConversation = async (difyConversationId: string) => {
    if (!user) return null;

    try {
      const { data, error } = await supabase
        .from('conversations')
        .insert({
          user_id: user.id,
          title: `å¯¹è¯ ${new Date().toLocaleString('zh-CN')}`,
          dify_conversation_id: difyConversationId,
        })
        .select()
        .single();

      if (error) throw error;
      return data.id;
    } catch (error) {
      console.error('Error creating conversation:', error);
      return null;
    }
  };

  const updateConversationDifyId = async (conversationId: string, difyConversationId: string) => {
    try {
      const { error } = await supabase
        .from('conversations')
        .update({ dify_conversation_id: difyConversationId })
        .eq('id', conversationId);

      if (error) throw error;
    } catch (error) {
      console.error('Error updating conversation dify_id:', error);
    }
  };

  const saveMessageToDatabase = async (conversationId: string, role: 'user' | 'assistant', content: string) => {
    try {
      const { error } = await supabase
        .from('messages')
        .insert({
          conversation_id: conversationId,
          role: role,
          content: content,
          created_at: new Date().toISOString(),
        });

      if (error) throw error;
    } catch (error) {
      console.error('Error saving message to database:', error);
      // Don't throw error here to avoid disrupting the chat flow
    }
  };

  const handleSendMessage = async (messageText: string, uploadedFileId?: string, uploadedFileName?: string) => {
    console.log('ğŸš€ handleSendMessage called with:', { messageText, uploadedFileId, uploadedFileName });
    
    if (!messageText.trim() || loading) {
      console.log('âš ï¸ Cannot send: input is empty or loading');
      return;
    }

    const userMessage: Message = {
      role: 'user',
      content: messageText,
      timestamp: new Date(),
      // Add attached file info if file was uploaded
      ...(uploadedFileId && uploadedFileName ? {
        attachedFile: {
          name: uploadedFileName,
          type: getFileType(uploadedFileName)
        }
      } : {})
    };

    setMessages((prev) => [...prev, userMessage]);
    setInput('');
    setLoading(true);

    let conversationIdForSaving = currentConversationId;
    let streamedContent = '';
    let streamedConversationId = '';

    // Check if this is the first message in a new conversation
    // Count only user messages (excluding the current one we just added)
    const userMessageCount = messages.filter(m => m.role === 'user').length;
    const isFirst = userMessageCount === 0;

    // Create a temporary thinking message
    const thinkingMessage: Message = {
      role: 'assistant',
      content: isFirst ? IDENTITY_CONFIRMATION_MESSAGE : THINKING_MESSAGES[0],
      timestamp: new Date(),
      isThinking: true,
    };
    setMessages((prev) => [...prev, thinkingMessage]);

    // Start the thinking animation (will not cycle if it's first message)
    startThinkingAnimation(isFirst);

    try {
      const requestBody: DifyChatRequestBody = {
        query: messageText,
        user_id: user!.id
      };

      // Only include conversation_id if we have a Dify conversation ID
      if (currentDifyConversationId) {
        requestBody.conversation_id = currentDifyConversationId;
      }

      // Add file if uploaded
      if (uploadedFileId) {
        console.log('ğŸ“ Adding file to request:', uploadedFileId);
        requestBody.files = [{
          type: "document",
          transfer_method: "local_file",
          upload_file_id: uploadedFileId
        }];
      } else {
        console.log('âš ï¸ No file ID provided');
      }

      console.log('ğŸ“¤ Calling dify_chat_v2 via native fetch');
      console.log('ğŸ“¦ Request body:', JSON.stringify(requestBody, null, 2));

      // Get session for authentication
      const session = await supabase.auth.getSession();
      
      // Use native fetch instead of supabase.functions.invoke
      const response = await fetch(
        `${supabase.supabaseUrl}/functions/v1/dify_chat_v2`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${session?.data?.session?.access_token}`
          },
          body: JSON.stringify(requestBody)
        }
      );

      if (!response.ok) {
        throw new Error(`Edge Function è°ƒç”¨å¤±è´¥: ${response.status}`);
      }

      const data = response.body;
      const error = null;

      // Stop thinking animation before processing response
      stopThinkingAnimation();

      // Check if we got a streaming response
      if (data instanceof ReadableStream) {
        console.log('âœ… Received streaming response');
        const reader = data.getReader();
        const decoder = new TextDecoder();

        // Update message to show it's now receiving content
        setMessages((prev) => {
          const newMessages = [...prev];
          const lastMessage = newMessages[newMessages.length - 1];
          if (lastMessage.role === 'assistant') {
            lastMessage.content = '';
            lastMessage.isThinking = false;
            lastMessage.isStreaming = true;
          }
          return newMessages;
        });

        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            const lines = chunk.split('\n');

            for (const line of lines) {
              if (line.startsWith('data: ')) {
                try {
                  const jsonStr = line.slice(6);
                  if (jsonStr.trim() === '') continue;
                  
                  const eventData = JSON.parse(jsonStr);
                  
                  
                  // Debug: Log the event data to understand the structure
                  console.log('ğŸ“¥ SSE Event:', eventData.event, eventData);
                  
                  // Handle different event types from Dify
                  // Dify can send different event types:
                  // - 'agent_message' or 'message': Contains incremental content
                  // - 'message_end': Marks the end of streaming
                  if (eventData.event === 'agent_message' || eventData.event === 'message') {
                    // Try to get incremental content from different possible fields
                    // Some Dify versions use 'delta', others use 'answer'
                    let deltaContent = '';
                    
                    if (eventData.delta) {
                      // Incremental content (preferred)
                      deltaContent = eventData.delta;
                    } else if (eventData.answer) {
                      // Full content - calculate the delta
                      deltaContent = eventData.answer.substring(streamedContent.length);
                    }
                    
                    if (deltaContent) {
                      streamedContent += deltaContent;
                      console.log('ğŸ“ Streaming delta:', deltaContent.length, 'chars, total:', streamedContent.length);
                    }
                    
                    setMessages((prev) => {
                      const newMessages = [...prev];
                      const lastMessage = newMessages[newMessages.length - 1];
                      if (lastMessage.role === 'assistant') {
                        lastMessage.content = streamedContent;
                      }
                      return newMessages;
                    });
                    streamedConversationId = eventData.conversation_id || '';
                    console.log('Stream ended, conversation_id:', streamedConversationId);
                  }
                } catch (parseError) {
                  console.error('Error parsing SSE data:', parseError);
                }
              }
            }
          }
        } finally {
          reader.releaseLock();
        }

        // Mark streaming as complete
        setMessages((prev) => {
          const newMessages = [...prev];
          const lastMessage = newMessages[newMessages.length - 1];
          if (lastMessage.role === 'assistant') {
            lastMessage.isStreaming = false;
          }
          return newMessages;
        });

      } else {
        // Fallback to non-streaming response
        console.log('Received non-streaming response, falling back');
        
        if (error) {
          console.error('Edge Function error:', error);
          throw new Error(error.message || 'è°ƒç”¨ Edge Function å¤±è´¥');
        }

        // Parse response as JSON for non-streaming
        const responseData = await response.json();
        
        if (!responseData || !responseData.success) {
          console.error('Edge Function returned error:', responseData);
          throw new Error(responseData?.error || 'Edge Function è¿”å›é”™è¯¯');
        }

        // Handle nested data structure
        const dataContent = responseData.data;
        console.log('Response data:', dataContent);
        
        streamedContent = dataContent.answer || 'æŠ±æ­‰,æˆ‘æ— æ³•å›ç­”è¿™ä¸ªé—®é¢˜ã€‚';
        streamedConversationId = dataContent.conversation_id || '';

        // Update the last message with the complete response
        setMessages((prev) => {
          const newMessages = [...prev];
          const lastMessage = newMessages[newMessages.length - 1];
          if (lastMessage.role === 'assistant') {
            lastMessage.content = streamedContent;
            lastMessage.isThinking = false;
            lastMessage.isStreaming = false;
          }
          return newMessages;
        });
      }

      // Handle conversation management
      if (!currentConversationId && streamedConversationId) {
        const newConversationId = await createNewConversation(streamedConversationId);
        if (newConversationId) {
          setCurrentConversationId(newConversationId);
          setCurrentDifyConversationId(streamedConversationId);
          conversationIdForSaving = newConversationId;
          await loadConversations();
        }
      } else if (currentConversationId && streamedConversationId && !currentDifyConversationId) {
        await updateConversationDifyId(currentConversationId, streamedConversationId);
        setCurrentDifyConversationId(streamedConversationId);
      }

      // Save both user message and assistant response to database
      if (conversationIdForSaving && streamedContent) {
        await saveMessageToDatabase(conversationIdForSaving, 'user', messageText);
        await saveMessageToDatabase(conversationIdForSaving, 'assistant', streamedContent);
      }

      console.log('âœ… Message sent successfully');
      toast.success('æ¶ˆæ¯å‘é€æˆåŠŸ');
    } catch (error: unknown) {
      console.error('âŒ Error sending message:', error);
      
      // Stop thinking animation on error
      stopThinkingAnimation();
      
      // Remove the user message and thinking/streaming assistant message if there was an error
      setMessages((prev) => prev.slice(0, -2));
      
      if (error instanceof Error) {
        toast.error(error.message || 'å‘é€æ¶ˆæ¯å¤±è´¥');
      } else {
        toast.error('å‘é€æ¶ˆæ¯å¤±è´¥,è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
      }
    } finally {
      setLoading(false);
    }
  };

  const handleSend = async () => {
    console.log('ğŸ”µ handleSend called');
    console.log('ğŸ“ Input:', input);
    console.log('ğŸ“ Uploaded file state:', uploadedFile);
    
    if (!input.trim() || loading) {
      console.log('âš ï¸ Cannot send: input is empty or loading');
      return;
    }
    
    // CRITICAL FIX: Save file info to local variables BEFORE any async operations
    // This prevents the state from being cleared before the message is sent
    const fileIdToSend = uploadedFile?.id;
    const fileNameToSend = uploadedFile?.name;
    console.log('ğŸ¯ File info to send:', { fileIdToSend, fileNameToSend });
    
    // Send message with the saved file info
    await handleSendMessage(input, fileIdToSend, fileNameToSend);
    
    // Clear uploaded file AFTER message is sent successfully
    console.log('ğŸ§¹ Clearing uploaded file state');
    setUploadedFile(null);
  };

  const handleIdentitySelect = async (identity: string) => {
    await handleSendMessage(identity);
  };

  const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // Reset file input
    e.target.value = '';

    if (!user) {
      toast.error('è¯·å…ˆç™»å½•');
      return;
    }

    try {
      // Check if user has permission to upload files
      const permissionCheck = await checkFeatureAccess(user.id, 'canUploadContract');
      
      if (!permissionCheck.hasAccess) {
        // Show upgrade dialog for trial users
        setShowUpgradeDialog(true);
        toast.info(permissionCheck.message);
        return;
      }

      // Validate file type
      const allowedTypes = ['.pdf', '.doc', '.docx', '.txt'];
      const fileExtension = '.' + file.name.split('.').pop()?.toLowerCase();
      
      if (!allowedTypes.includes(fileExtension)) {
        toast.error('ä»…æ”¯æŒ PDF, DOC, DOCX, TXT æ ¼å¼çš„æ–‡ä»¶');
        return;
      }

      // Validate file size (max 10MB)
      const maxSize = 10 * 1024 * 1024; // 10MB
      if (file.size > maxSize) {
        toast.error('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡ 10MB');
        return;
      }

      setUploadingFile(true);
      toast.info('æ­£åœ¨ä¸Šä¼ æ–‡ä»¶...');

      // Create FormData for file upload
      const formData = new FormData();
      formData.append('file', file);
      formData.append('user', user.id);

      console.log('ğŸ“¤ Uploading file to dify-upload-file Edge Function');

      // Upload file via Edge Function
      // Note: supabase.functions.invoke automatically includes authentication
      const { data, error } = await supabase.functions.invoke('dify-upload-file', {
        body: formData
      });

      if (error) {
        console.error('âŒ File upload error:', error);
        throw new Error(error.message || 'æ–‡ä»¶ä¸Šä¼ å¤±è´¥');
      }

      if (!data || !data.id) {
        console.error('âŒ Invalid upload response:', data);
        throw new Error('ä¸Šä¼ å“åº”æ— æ•ˆ');
      }

      console.log('âœ… File uploaded successfully:', data);
      console.log('ğŸ“ File ID:', data.id);
      toast.success('æ–‡ä»¶ä¸Šä¼ æˆåŠŸ');

      // Store uploaded file info instead of auto-sending
      const uploadedFileInfo = {
        id: data.id,
        name: file.name
      };
      console.log('ğŸ’¾ Storing uploaded file info:', uploadedFileInfo);
      setUploadedFile(uploadedFileInfo);

    } catch (error: unknown) {
      console.error('âŒ Error uploading file:', error);
      if (error instanceof Error) {
        toast.error(error.message || 'æ–‡ä»¶ä¸Šä¼ å¤±è´¥');
      } else {
        toast.error('æ–‡ä»¶ä¸Šä¼ å¤±è´¥,è¯·é‡è¯•');
      }
    } finally {
      setUploadingFile(false);
    }
  };

  const handleRemoveFile = () => {
    console.log('ğŸ—‘ï¸ Removing uploaded file');
    setUploadedFile(null);
    toast.info('å·²ç§»é™¤æ–‡ä»¶');
  };

  const loadConversation = async (conversationId: string) => {
    try {
      const { data: convData, error: convError } = await supabase
        .from('conversations')
        .select('dify_conversation_id')
        .eq('id', conversationId)
        .single();

      if (convError) throw convError;

      const { data, error } = await supabase
        .from('messages')
        .select('*')
        .eq('conversation_id', conversationId)
        .order('created_at', { ascending: true });

      if (error) throw error;

      const loadedMessages: Message[] = (data || []).map((msg) => ({
        role: msg.role as 'user' | 'assistant',
        content: msg.content,
        timestamp: new Date(msg.created_at),
      }));

      setMessages(loadedMessages);
      setCurrentConversationId(conversationId);
      setCurrentDifyConversationId(convData?.dify_conversation_id || null);
    } catch (error) {
      console.error('Error loading conversation:', error);
      toast.error('åŠ è½½å¯¹è¯å¤±è´¥');
    }
  };

  const deleteConversation = async (conversationId: string) => {
    try {
      const { error } = await supabase
        .from('conversations')
        .delete()
        .eq('id', conversationId);

      if (error) throw error;

      if (currentConversationId === conversationId) {
        setMessages([]);
        setCurrentConversationId(null);
        setCurrentDifyConversationId(null);
      }

      await loadConversations();
      setShowDeleteDialog(false);
      setConversationToDelete(null);
      toast.success('å¯¹è¯å·²åˆ é™¤');
    } catch (error) {
      console.error('Error deleting conversation:', error);
      toast.error('åˆ é™¤å¯¹è¯å¤±è´¥');
    }
  };

  const handleSelectAll = (checked: boolean) => {
    if (checked) {
      setSelectedConversations(new Set(conversations.map((c) => c.id)));
    } else {
      setSelectedConversations(new Set());
    }
  };

  const handleSelectConversation = (conversationId: string, checked: boolean) => {
    const newSelected = new Set(selectedConversations);
    if (checked) {
      newSelected.add(conversationId);
    } else {
      newSelected.delete(conversationId);
    }
    setSelectedConversations(newSelected);
  };

  const handleBatchDelete = async () => {
    if (selectedConversations.size === 0) return;

    try {
      const { error } = await supabase
        .from('conversations')
        .delete()
        .in('id', Array.from(selectedConversations));

      if (error) throw error;

      if (currentConversationId && selectedConversations.has(currentConversationId)) {
        setMessages([]);
        setCurrentConversationId(null);
        setCurrentDifyConversationId(null);
      }

      setSelectedConversations(new Set());
      await loadConversations();
      setShowBatchDeleteDialog(false);
      toast.success(`å·²åˆ é™¤ ${selectedConversations.size} ä¸ªå¯¹è¯`);
    } catch (error) {
      console.error('Error batch deleting conversations:', error);
      toast.error('æ‰¹é‡åˆ é™¤å¤±è´¥');
    }
  };

  const startNewChat = () => {
    setMessages([]);
    setCurrentConversationId(null);
    setCurrentDifyConversationId(null);
    setUploadedFile(null);
  };

  const handleDeleteClick = (conversationId: string) => {
    setConversationToDelete(conversationId);
    setShowDeleteDialog(true);
  };

  const handleBackToHome = () => {
    navigate('/');
  };

  // Check if input should be disabled (when showing identity selection)
  const isInputDisabled = messages.length === 0;

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50">
      <Navbar />
      
      {/* Back to Home Button */}
      <div className="container mx-auto px-4 pt-4">
        <Button
          onClick={handleBackToHome}
          variant="ghost"
          className="mb-2 text-gray-600 hover:text-blue-600 hover:bg-blue-50 transition-all duration-200"
        >
          <ArrowLeft className="h-4 w-4 mr-2" />
          è¿”å›ä¸»é¡µ
        </Button>
      </div>
      
      <ConfirmDialog
        open={showBatchDeleteDialog}
        onOpenChange={setShowBatchDeleteDialog}
        title="ç¡®è®¤æ‰¹é‡åˆ é™¤?"
        description={`æ‚¨ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedConversations.size} ä¸ªå¯¹è¯å—?åˆ é™¤å¯¹è¯å°†æ°¸ä¹…åˆ é™¤æ‰€æœ‰å¯¹è¯å†…å®¹,åŒ…æ‹¬åˆåŒæ•°æ®ç­‰,æ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`}
        onConfirm={handleBatchDelete}
        confirmText="ç¡®è®¤åˆ é™¤"
        cancelText="å–æ¶ˆ"
        variant="destructive"
      />

      <ConfirmDialog
        open={showDeleteDialog}
        onOpenChange={setShowDeleteDialog}
        title="ç¡®è®¤åˆ é™¤å¯¹è¯?"
        description="åˆ é™¤å¯¹è¯å°†æ°¸ä¹…åˆ é™¤æ‰€æœ‰å¯¹è¯å†…å®¹,åŒ…æ‹¬åˆåŒæ•°æ®ç­‰,æ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚"
        onConfirm={() => conversationToDelete && deleteConversation(conversationToDelete)}
        confirmText="ç¡®è®¤åˆ é™¤"
        cancelText="å–æ¶ˆ"
        variant="destructive"
      />

      <UpgradeDialog 
        open={showUpgradeDialog} 
        onOpenChange={setShowUpgradeDialog}
      />

      <div className="container mx-auto px-4 pb-8">
        <div className="flex gap-6 h-[calc(100vh-14rem)]">
          {/* å·¦ä¾§è¾¹æ  - å†å²å¯¹è¯ */}
          <Card className="w-72 p-4 overflow-y-auto bg-white/80 backdrop-blur-sm border-gray-200 shadow-lg">
            <Button
              onClick={startNewChat}
              className="w-full mb-4 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white shadow-md hover:shadow-lg transition-all duration-200"
            >
              <MessageSquare className="h-4 w-4 mr-2" />
              æ–°å¯¹è¯
            </Button>

            <div className="space-y-2">
              <div className="flex items-center justify-between mb-2">
                <h3 className="text-sm font-semibold text-gray-700">å†å²å¯¹è¯</h3>
                {conversations.length > 0 && (
                  <div className="flex items-center gap-2">
                    <Checkbox
                      checked={selectedConversations.size === conversations.length && conversations.length > 0}
                      onCheckedChange={handleSelectAll}
                      className="h-4 w-4"
                    />
                    <span className="text-xs text-gray-500">å…¨é€‰</span>
                  </div>
                )}
              </div>

              {selectedConversations.size > 0 && (
                <Button
                  onClick={() => setShowBatchDeleteDialog(true)}
                  variant="outline"
                  size="sm"
                  className="w-full mb-2 text-red-600 hover:text-red-700 hover:bg-red-50 border-red-200"
                >
                  <Trash2 className="h-3 w-3 mr-2" />
                  åˆ é™¤é€‰ä¸­ ({selectedConversations.size})
                </Button>
              )}

              {conversations.map((conv) => (
                <div
                  key={conv.id}
                  className={`group flex items-center gap-2 p-3 hover:bg-blue-50 rounded-lg transition-all duration-200 ${
                    currentConversationId === conv.id ? 'bg-blue-100 border-2 border-blue-300 shadow-sm' : 'border border-transparent'
                  }`}
                >
                  <Checkbox
                    checked={selectedConversations.has(conv.id)}
                    onCheckedChange={(checked) => handleSelectConversation(conv.id, checked as boolean)}
                    className="h-4 w-4"
                  />
                  <div
                    onClick={() => loadConversation(conv.id)}
                    className="flex-1 truncate text-sm cursor-pointer text-gray-700 hover:text-blue-600"
                  >
                    {conv.title}
                  </div>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => handleDeleteClick(conv.id)}
                    className="opacity-0 group-hover:opacity-100 h-7 w-7 p-0 hover:bg-red-50 hover:text-red-600"
                  >
                    <Trash2 className="h-3 w-3" />
                  </Button>
                </div>
              ))}
            </div>
          </Card>

          {/* ä¸»èŠå¤©åŒºåŸŸ */}
          <Card className="flex-1 flex flex-col bg-white/90 backdrop-blur-sm border-gray-200 shadow-xl">
            <div className="flex-1 overflow-y-auto p-6 space-y-4 scroll-smooth">
              {messages.length === 0 ? (
                <div className="flex items-center justify-center h-full animate-fadeIn">
                  <Card className="max-w-3xl w-full p-8 shadow-xl border-2 border-blue-100 bg-gradient-to-br from-white to-blue-50">
                    <div className="text-center space-y-6">
                      {/* Welcome Title */}
                      <div className="space-y-3">
                        <div className="flex items-center justify-center mb-4">
                          <div className="relative">
                            <MessageSquare className="h-16 w-16 text-blue-600" />
                            <div className="absolute inset-0 bg-blue-400/20 blur-xl rounded-full animate-pulse"></div>
                          </div>
                        </div>
                        <h2 className="text-3xl font-bold bg-gradient-to-r from-blue-600 to-indigo-600 bg-clip-text text-transparent">
                          æ¬¢è¿ä½¿ç”¨PolicyBridge.AI!
                        </h2>
                        <p className="text-gray-600 text-lg">
                          ä¸ºäº†æ›´å¥½çš„è§£å†³æ‚¨çš„é—®é¢˜,è¯·é€‰æ‹©æ‚¨çš„èº«ä»½:
                        </p>
                        <p className="text-gray-500 text-sm">
                          é€‰æ‹©æ‚¨çš„èº«ä»½å,æˆ‘ä»¬èƒ½æ›´åŠ ç²¾å‡†çš„ä¸ºæ‚¨æœåŠ¡
                        </p>
                      </div>

                      {/* Identity Selection Buttons - Two Column Layout */}
                      <div className="grid grid-cols-2 gap-4 pt-4">
                        {/* Left Column - 4 buttons */}
                        <div className="space-y-3">
                          <Button
                            onClick={() => handleIdentitySelect('è·¨å¢ƒå–å®¶/ä¾›åº”å•†')}
                            variant="outline"
                            className="w-full h-14 text-base font-medium hover:bg-blue-50 hover:border-blue-400 hover:text-blue-700 hover:shadow-md transition-all duration-200"
                            disabled={loading}
                          >
                            è·¨å¢ƒå–å®¶/ä¾›åº”å•†
                          </Button>

                          <Button
                            onClick={() => handleIdentitySelect('è·¨å¢ƒä¹°å®¶')}
                            variant="outline"
                            className="w-full h-14 text-base font-medium hover:bg-green-50 hover:border-green-400 hover:text-green-700 hover:shadow-md transition-all duration-200"
                            disabled={loading}
                          >
                            è·¨å¢ƒä¹°å®¶
                          </Button>

                          <Button
                            onClick={() => handleIdentitySelect('æ¸ é“/ä¸­é—´å•†')}
                            variant="outline"
                            className="w-full h-14 text-base font-medium hover:bg-purple-50 hover:border-purple-400 hover:text-purple-700 hover:shadow-md transition-all duration-200"
                            disabled={loading}
                          >
                            æ¸ é“/ä¸­é—´å•†
                          </Button>

                          <Button
                            onClick={() => handleIdentitySelect('è´§è¿ä»£ç† (Logistics)')}
                            variant="outline"
                            className="w-full h-14 text-base font-medium hover:bg-orange-50 hover:border-orange-400 hover:text-orange-700 hover:shadow-md transition-all duration-200"
                            disabled={loading}
                          >
                            è´§è¿ä»£ç† (Logistics)
                          </Button>
                        </div>

                        {/* Right Column - 3 buttons */}
                        <div className="space-y-3">
                          <Button
                            onClick={() => handleIdentitySelect('å“ç‰Œ/æŠ€æœ¯æ–¹ (IP/OEM)')}
                            variant="outline"
                            className="w-full h-14 text-base font-medium hover:bg-pink-50 hover:border-pink-400 hover:text-pink-700 hover:shadow-md transition-all duration-200"
                            disabled={loading}
                          >
                            å“ç‰Œ/æŠ€æœ¯æ–¹ (IP/OEM)
                          </Button>

                          <Button
                            onClick={() => handleIdentitySelect('æµ·å¤–ä»“ (WMS/3PL)')}
                            variant="outline"
                            className="w-full h-14 text-base font-medium hover:bg-teal-50 hover:border-teal-400 hover:text-teal-700 hover:shadow-md transition-all duration-200"
                            disabled={loading}
                          >
                            æµ·å¤–ä»“ (WMS/3PL)
                          </Button>

                          <Button
                            onClick={() => handleIdentitySelect('é‡‘è/æ”¯ä»˜ (Financier)')}
                            variant="outline"
                            className="w-full h-14 text-base font-medium hover:bg-indigo-50 hover:border-indigo-400 hover:text-indigo-700 hover:shadow-md transition-all duration-200"
                            disabled={loading}
                          >
                            é‡‘è/æ”¯ä»˜ (Financier)
                          </Button>
                        </div>
                      </div>

                      {loading && (
                        <div className="flex items-center justify-center pt-4">
                          <Loader2 className="h-6 w-6 animate-spin text-blue-600" />
                          <span className="ml-2 text-gray-600">æ­£åœ¨å¤„ç†...</span>
                        </div>
                      )}
                    </div>
                  </Card>
                </div>
              ) : (
                <>
                  {messages.map((message, index) => (
                    <div
                      key={index}
                      className={`flex gap-3 animate-fadeIn ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}
                      style={{ animationDelay: `${index * 0.05}s` }}
                    >
                      {message.role === 'assistant' && (
                        <Avatar className="w-10 h-10 border-2 border-amber-300 shadow-md flex-shrink-0">
                          <AvatarFallback className="bg-gradient-to-br from-amber-500 to-amber-600 text-white">
                            <Scale className="w-5 h-5" />
                          </AvatarFallback>
                        </Avatar>
                      )}

                      <div
                        className={`max-w-[70%] p-4 rounded-2xl shadow-md transition-all duration-300 hover:shadow-lg ${
                          message.role === 'user'
                            ? 'bg-gradient-to-br from-blue-600 to-indigo-600 text-white'
                            : 'bg-white border border-gray-200 text-gray-900'
                        }`}
                      >
                        {message.isThinking ? (
                          <div className="flex items-center gap-2">
                            <Loader2 className="h-4 w-4 animate-spin text-blue-600" />
                            <span className="text-gray-700">
                              {isFirstMessage ? IDENTITY_CONFIRMATION_MESSAGE : THINKING_MESSAGES[thinkingMessageIndex]}
                            </span>
                            <span className="inline-flex gap-0.5">
                              <span className="animate-bounce text-blue-600" style={{ animationDelay: '0ms' }}>.</span>
                              <span className="animate-bounce text-blue-600" style={{ animationDelay: '150ms' }}>.</span>
                              <span className="animate-bounce text-blue-600" style={{ animationDelay: '300ms' }}>.</span>
                            </span>
                          </div>
                        ) : (
                          <>
                            {/* Show attached file info for user messages */}
                            {message.role === 'user' && message.attachedFile && (
                              <div className="flex items-center gap-2 mb-3 pb-3 border-b border-white/20">
                                <FileIcon type={message.attachedFile.type} />
                                <span className="text-sm text-white/90 truncate flex-1">{message.attachedFile.name}</span>
                              </div>
                            )}
                            <div className="whitespace-pre-wrap leading-relaxed">
                              {parseMessageContent(message.content, message.role === 'user')}
                            </div>
                            {message.isStreaming && (
                              <span className="inline-block w-1 h-5 ml-1 bg-blue-600 animate-pulse" />
                            )}
                            <p className={`text-xs mt-2 ${message.role === 'user' ? 'text-blue-100' : 'text-gray-500'}`}>
                              {message.timestamp.toLocaleTimeString('zh-CN')}
                            </p>
                          </>
                        )}
                      </div>

                      {message.role === 'user' && (
                        <Avatar className="w-10 h-10 border-2 border-blue-200 shadow-md flex-shrink-0">
                          <AvatarFallback className="bg-gradient-to-br from-blue-600 to-purple-600 text-white">
                            <User className="w-5 h-5" />
                          </AvatarFallback>
                        </Avatar>
                      )}
                    </div>
                  ))}
                  <div ref={messagesEndRef} />
                </>
              )}
            </div>

            {/* è¾“å…¥åŒºåŸŸ */}
            <div className="border-t border-gray-200 bg-white/80 backdrop-blur-sm p-4">
              {/* Uploaded File Display */}
              {uploadedFile && (
                <div className="mb-3 flex items-center gap-2 p-3 bg-blue-50 border border-blue-200 rounded-lg">
                  <FileText className="h-5 w-5 text-blue-600 flex-shrink-0" />
                  <span className="text-sm text-gray-700 flex-1 truncate">{uploadedFile.name}</span>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={handleRemoveFile}
                    className="h-7 w-7 p-0 hover:bg-red-50 hover:text-red-600"
                  >
                    <X className="h-4 w-4" />
                  </Button>
                </div>
              )}
              
              <div className="flex gap-3 items-end">
                <Button 
                  variant="outline" 
                  size="icon" 
                  disabled={isInputDisabled || loading || uploadingFile}
                  className="hover:bg-blue-50 hover:border-blue-300 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                  onClick={() => document.getElementById('file-upload')?.click()}
                >
                  {uploadingFile ? (
                    <Loader2 className="h-4 w-4 animate-spin" />
                  ) : (
                    <Upload className="h-4 w-4" />
                  )}
                </Button>
                <input
                  id="file-upload"
                  type="file"
                  className="hidden"
                  onChange={handleFileUpload}
                  accept=".pdf,.doc,.docx,.txt"
                  disabled={isInputDisabled || loading || uploadingFile}
                />
                <div className="flex-1 relative group">
                  <Textarea
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        handleSend();
                      }
                    }}
                    placeholder={isInputDisabled ? "è¯·å…ˆé€‰æ‹©æ‚¨çš„èº«ä»½..." : uploadedFile ? "è¾“å…¥æ‚¨çš„é—®é¢˜(å·²é™„åŠ æ–‡ä»¶)..." : "è¾“å…¥æ‚¨çš„é—®é¢˜..."}
                    className="min-h-[60px] max-h-[200px] resize-none bg-white border-gray-300 focus:border-blue-500 focus:ring-2 focus:ring-blue-200 rounded-xl transition-all duration-300 disabled:bg-gray-50 disabled:text-gray-400 disabled:cursor-not-allowed"
                    disabled={isInputDisabled || loading}
                  />
                  <div className="absolute inset-0 rounded-xl bg-gradient-to-r from-blue-500/0 via-indigo-500/0 to-purple-500/0 group-focus-within:from-blue-500/5 group-focus-within:via-indigo-500/5 group-focus-within:to-purple-500/5 pointer-events-none transition-all duration-500"></div>
                </div>
                <Button
                  onClick={handleSend}
                  disabled={isInputDisabled || !input.trim() || loading}
                  className="h-[60px] px-6 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white rounded-xl shadow-lg hover:shadow-xl transition-all duration-300 hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:scale-100"
                >
                  {loading ? (
                    <Loader2 className="w-5 h-5 animate-spin" />
                  ) : (
                    <Send className="w-5 h-5" />
                  )}
                </Button>
              </div>
            </div>
          </Card>
        </div>
      </div>

      <style>{`
        @keyframes fadeIn {
          from {
            opacity: 0;
            transform: translateY(10px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }

        .animate-fadeIn {
          animation: fadeIn 0.4s ease-out forwards;
        }

        /* Custom scrollbar for light theme */
        ::-webkit-scrollbar {
          width: 8px;
        }

        ::-webkit-scrollbar-track {
          background: rgba(243, 244, 246, 0.5);
          border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
          background: linear-gradient(to bottom, #3b82f6, #6366f1);
          border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
          background: linear-gradient(to bottom, #2563eb, #4f46e5);
        }
      `}</style>
    </div>
  );
}