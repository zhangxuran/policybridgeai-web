{"version":3,"file":"react-resizable-panels.cjs","sources":["../lib/utils/assert.ts","../lib/global/dom/calculateAvailableGroupSize.ts","../lib/components/group/sortByElementOffset.ts","../lib/utils/isHTMLElement.ts","../lib/global/utils/getDistanceBetweenPointAndRect.ts","../lib/global/utils/findClosestRect.ts","../lib/global/utils/isCoarsePointer.ts","../lib/global/dom/calculateHitRegions.ts","../lib/global/styles/convertEmToPixels.ts","../lib/global/styles/convertRemToPixels.ts","../lib/global/styles/convertVhToPixels.ts","../lib/global/styles/convertVwToPixels.ts","../lib/global/styles/parseSizeAndUnit.ts","../lib/global/styles/sizeStyleToPixels.ts","../lib/global/utils/formatLayoutNumber.ts","../lib/global/dom/calculatePanelConstraints.ts","../lib/utils/EventEmitter.ts","../lib/global/utils/layoutNumbersEqual.ts","../lib/global/mutableState.ts","../lib/global/utils/findClosestHitRegion.ts","../lib/utils/isShadowRoot.ts","../lib/vendor/stacking-order.ts","../lib/global/utils/doRectsIntersect.ts","../lib/global/utils/isViableHitTarget.ts","../lib/global/utils/findMatchingHitRegions.ts","../lib/utils/isArrayEqual.ts","../lib/global/utils/compareLayoutNumbers.ts","../lib/global/utils/validatePanelSize.ts","../lib/global/utils/adjustLayoutByDelta.ts","../lib/global/utils/layoutsEqual.ts","../lib/global/utils/validatePanelGroupLayout.ts","../lib/global/utils/getImperativePanelMethods.ts","../lib/global/event-handlers/onDocumentDoubleClick.ts","../lib/global/utils/findSeparatorGroup.ts","../lib/global/utils/getImperativeGroupMethods.ts","../lib/global/utils/getMountedGroup.ts","../lib/global/utils/adjustLayoutForSeparator.ts","../lib/global/event-handlers/onDocumentKeyDown.ts","../lib/global/event-handlers/onDocumentPointerDown.ts","../lib/constants.ts","../lib/global/cursor/supportsAdvancedCursorStyles.ts","../lib/global/cursor/getCursorStyle.ts","../lib/global/cursor/updateCursorStyle.ts","../lib/global/utils/updateActiveHitRegion.ts","../lib/global/event-handlers/onDocumentPointerLeave.ts","../lib/global/event-handlers/onDocumentPointerMove.ts","../lib/global/event-handlers/onDocumentPointerUp.ts","../lib/global/utils/calculateDefaultLayout.ts","../lib/global/utils/notifyPanelOnResize.ts","../lib/global/utils/objectsEqual.ts","../lib/global/utils/validateLayoutKeys.ts","../lib/global/mountGroup.ts","../lib/hooks/useForceUpdate.ts","../lib/hooks/useId.ts","../lib/hooks/useIsomorphicLayoutEffect.ts","../lib/hooks/useStableCallback.ts","../lib/hooks/useMergedRefs.ts","../lib/hooks/useStableObject.ts","../lib/components/group/GroupContext.ts","../lib/components/group/useGroupImperativeHandle.ts","../lib/components/group/Group.tsx","../lib/components/group/auto-save/getStorageKey.ts","../lib/components/group/useDefaultLayout.ts","../lib/components/group/useGroupCallbackRef.ts","../lib/components/group/useGroupRef.ts","../lib/components/group/useGroupContext.ts","../lib/components/panel/usePanelImperativeHandle.ts","../lib/components/panel/Panel.tsx","../lib/components/panel/usePanelCallbackRef.ts","../lib/components/panel/usePanelRef.ts","../lib/global/utils/calculateSeparatorAriaValues.ts","../lib/components/separator/Separator.tsx"],"sourcesContent":["export function assert(\n  expectedCondition: unknown,\n  message: string = \"Assertion error\"\n): asserts expectedCondition {\n  if (!expectedCondition) {\n    throw Error(message);\n  }\n}\n","import type { RegisteredGroup } from \"../../components/group/types\";\n\nexport function calculateAvailableGroupSize({\n  group\n}: {\n  group: RegisteredGroup;\n}) {\n  const { orientation, panels } = group;\n\n  return panels.reduce((totalSize, panel) => {\n    totalSize +=\n      orientation === \"horizontal\"\n        ? panel.element.offsetWidth\n        : panel.element.offsetHeight;\n    return totalSize;\n  }, 0);\n}\n","import type { Orientation } from \"./types\";\n\nexport function sortByElementOffset<\n  Type extends { element: HTMLElement },\n  ReturnType extends Type[]\n>(orientation: Orientation, panelsOrSeparators: Type[]): ReturnType {\n  return panelsOrSeparators.sort(\n    orientation === \"horizontal\" ? horizontalSort : verticalSort\n  ) as ReturnType;\n}\n\nfunction horizontalSort<Type extends { element: HTMLElement }>(\n  a: Type,\n  b: Type\n) {\n  const delta = a.element.offsetLeft - b.element.offsetLeft;\n  if (delta !== 0) {\n    return delta;\n  }\n  return a.element.offsetWidth - b.element.offsetWidth;\n}\n\nfunction verticalSort<Type extends { element: HTMLElement }>(a: Type, b: Type) {\n  const delta = a.element.offsetTop - b.element.offsetTop;\n  if (delta !== 0) {\n    return delta;\n  }\n  return a.element.offsetHeight - b.element.offsetHeight;\n}\n","// Detects HTMLElement without requiring instanceof and browser globals\nexport function isHTMLElement(value: unknown): value is HTMLElement {\n  return (\n    value !== null &&\n    typeof value === \"object\" &&\n    \"nodeType\" in value &&\n    value.nodeType === Node.ELEMENT_NODE\n  );\n}\n","import type { Point } from \"../../types\";\n\nexport function getDistanceBetweenPointAndRect(\n  point: Point,\n  rect: DOMRectReadOnly\n) {\n  return {\n    x:\n      point.x >= rect.left && point.x <= rect.right\n        ? 0\n        : Math.min(\n            Math.abs(point.x - rect.left),\n            Math.abs(point.x - rect.right)\n          ),\n    y:\n      point.y >= rect.top && point.y <= rect.bottom\n        ? 0\n        : Math.min(\n            Math.abs(point.y - rect.top),\n            Math.abs(point.y - rect.bottom)\n          )\n  };\n}\n","import type { Orientation } from \"../../components/group/types\";\nimport { assert } from \"../../utils/assert\";\nimport { getDistanceBetweenPointAndRect } from \"./getDistanceBetweenPointAndRect\";\n\nexport function findClosestRect({\n  orientation,\n  rects,\n  targetRect\n}: {\n  orientation: Orientation;\n  rects: DOMRectReadOnly[];\n  targetRect: DOMRectReadOnly;\n}): DOMRectReadOnly {\n  const centerPoint = {\n    x: targetRect.x + targetRect.width / 2,\n    y: targetRect.y + targetRect.height / 2\n  };\n\n  let closestRect: DOMRectReadOnly | undefined = undefined;\n  let minDistance = Number.MAX_VALUE;\n\n  for (const rect of rects) {\n    const { x, y } = getDistanceBetweenPointAndRect(centerPoint, rect);\n\n    const distance = orientation === \"horizontal\" ? x : y;\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestRect = rect;\n    }\n  }\n\n  assert(closestRect, \"No rect found\");\n\n  return closestRect;\n}\n","let cached: boolean | undefined = undefined;\n\n/**\n * Caches and returns matchMedia()'s computed value for \"pointer:coarse\"\n */\nexport function isCoarsePointer(): boolean {\n  if (cached === undefined) {\n    if (typeof matchMedia === \"function\") {\n      cached = !!matchMedia(\"(pointer:coarse)\").matches;\n    } else {\n      cached = false;\n    }\n  }\n\n  return cached;\n}\n","import { sortByElementOffset } from \"../../components/group/sortByElementOffset\";\nimport type { RegisteredGroup } from \"../../components/group/types\";\nimport type { RegisteredPanel } from \"../../components/panel/types\";\nimport type { RegisteredSeparator } from \"../../components/separator/types\";\nimport { isHTMLElement } from \"../../utils/isHTMLElement\";\nimport { findClosestRect } from \"../utils/findClosestRect\";\nimport { isCoarsePointer } from \"../utils/isCoarsePointer\";\nimport { calculateAvailableGroupSize } from \"./calculateAvailableGroupSize\";\n\ntype PanelsTuple = [panel: RegisteredPanel, panel: RegisteredPanel];\n\nexport type HitRegion = {\n  group: RegisteredGroup;\n  groupSize: number;\n  panels: PanelsTuple;\n  rect: DOMRect;\n  separator?: RegisteredSeparator | undefined;\n};\n\n/**\n * Determines hit regions for a Group; a hit region is either:\n * - 1: An explicit Separator element\n * - 2: The edge of a Panel element that has another Panel beside it\n *\n * This method determines bounding rects of all regions for the particular group.\n */\nexport function calculateHitRegions(group: RegisteredGroup) {\n  const { element: groupElement, orientation, panels, separators } = group;\n\n  // Sort elements by offset before traversing\n  const sortedChildElements: HTMLElement[] = sortByElementOffset(\n    orientation,\n    Array.from(groupElement.children)\n      .filter(isHTMLElement)\n      .map((element) => ({ element: element as HTMLElement }))\n  ).map(({ element }) => element);\n\n  const hitRegions: HitRegion[] = [];\n\n  let hasInterleavedStaticContent = false;\n  let prevPanel: RegisteredPanel | undefined = undefined;\n  let pendingSeparators: RegisteredSeparator[] = [];\n\n  for (const childElement of sortedChildElements) {\n    if (childElement.hasAttribute(\"data-panel\")) {\n      const panelData = panels.find(\n        (current) => current.element === childElement\n      );\n      if (panelData) {\n        if (prevPanel) {\n          const prevRect = prevPanel.element.getBoundingClientRect();\n          const rect = childElement.getBoundingClientRect();\n\n          let pendingRectsOrSeparators: (DOMRect | RegisteredSeparator)[];\n\n          // If an explicit Separator has been rendered, always watch it\n          // Otherwise watch the entire space between the panels\n          // The one caveat is when there are non-interactive element(s) between panels,\n          // in which case we may need to watch individual panel edges\n          if (hasInterleavedStaticContent) {\n            const firstPanelEdgeRect =\n              orientation === \"horizontal\"\n                ? new DOMRect(prevRect.right, prevRect.top, 0, prevRect.height)\n                : new DOMRect(\n                    prevRect.left,\n                    prevRect.bottom,\n                    prevRect.width,\n                    0\n                  );\n            const secondPanelEdgeRect =\n              orientation === \"horizontal\"\n                ? new DOMRect(rect.left, rect.top, 0, rect.height)\n                : new DOMRect(rect.left, rect.top, rect.width, 0);\n\n            switch (pendingSeparators.length) {\n              case 0: {\n                pendingRectsOrSeparators = [\n                  firstPanelEdgeRect,\n                  secondPanelEdgeRect\n                ];\n                break;\n              }\n              case 1: {\n                const separator = pendingSeparators[0];\n                const closestRect = findClosestRect({\n                  orientation,\n                  rects: [prevRect, rect],\n                  targetRect: separator.element.getBoundingClientRect()\n                });\n\n                pendingRectsOrSeparators = [\n                  separator,\n                  closestRect === prevRect\n                    ? secondPanelEdgeRect\n                    : firstPanelEdgeRect\n                ];\n                break;\n              }\n              default: {\n                pendingRectsOrSeparators = pendingSeparators;\n                break;\n              }\n            }\n          } else {\n            if (pendingSeparators.length) {\n              pendingRectsOrSeparators = pendingSeparators;\n            } else {\n              pendingRectsOrSeparators = [\n                orientation === \"horizontal\"\n                  ? new DOMRect(\n                      prevRect.right,\n                      rect.top,\n                      rect.left - prevRect.right,\n                      rect.height\n                    )\n                  : new DOMRect(\n                      rect.left,\n                      prevRect.bottom,\n                      rect.width,\n                      rect.top - prevRect.bottom\n                    )\n              ];\n            }\n          }\n\n          for (const rectOrSeparator of pendingRectsOrSeparators) {\n            let rect =\n              \"width\" in rectOrSeparator\n                ? rectOrSeparator\n                : rectOrSeparator.element.getBoundingClientRect();\n\n            // Ensure that Separators or Panel \"edges\" have large enough hit areas to be interacted with easily\n            // Apple interface guidelines suggest 20pt (27) on desktops and 28pt (37px) for touch devices\n            // https://developer.apple.com/design/human-interface-guidelines/accessibility\n            const minHitTargetSize = isCoarsePointer() ? 37 : 27;\n            if (rect.width < minHitTargetSize) {\n              const delta = minHitTargetSize - rect.width;\n              rect = new DOMRect(\n                rect.x - delta / 2,\n                rect.y,\n                rect.width + delta,\n                rect.height\n              );\n            }\n            if (rect.height < minHitTargetSize) {\n              const delta = minHitTargetSize - rect.height;\n              rect = new DOMRect(\n                rect.x,\n                rect.y - delta / 2,\n                rect.width,\n                rect.height + delta\n              );\n            }\n\n            hitRegions.push({\n              group,\n              groupSize: calculateAvailableGroupSize({ group }),\n              panels: [prevPanel, panelData],\n              separator:\n                \"width\" in rectOrSeparator ? undefined : rectOrSeparator,\n              rect\n            });\n          }\n        }\n\n        hasInterleavedStaticContent = false;\n        prevPanel = panelData;\n        pendingSeparators = [];\n      }\n    } else if (childElement.hasAttribute(\"data-separator\")) {\n      const separatorData = separators.find(\n        (current) => current.element === childElement\n      );\n      if (separatorData) {\n        // Separators will be included implicitly in the area between the previous and next panel\n        // It's important to track them though, to handle the scenario of non-interactive group content\n        pendingSeparators.push(separatorData);\n      } else {\n        prevPanel = undefined;\n        pendingSeparators = [];\n      }\n    } else {\n      hasInterleavedStaticContent = true;\n    }\n  }\n\n  return hitRegions;\n}\n","export function convertEmToPixels(element: Element, value: number) {\n  const style = getComputedStyle(element);\n  const fontSize = parseFloat(style.fontSize);\n\n  return value * fontSize;\n}\n","export function convertRemToPixels(element: Element, value: number) {\n  const style = getComputedStyle(element.ownerDocument.body);\n  const fontSize = parseFloat(style.fontSize);\n\n  return value * fontSize;\n}\n","export function convertVhToPixels(value: number) {\n  return (value / 100) * window.innerHeight;\n}\n","export function convertVwToPixels(value: number) {\n  return (value / 100) * window.innerWidth;\n}\n","import type { SizeUnit } from \"../../components/panel/types\";\n\nexport function parseSizeAndUnit(\n  size: number | string\n): [numeric: number, size: SizeUnit] {\n  switch (typeof size) {\n    case \"number\": {\n      return [size, \"px\"];\n    }\n    case \"string\": {\n      const numeric = parseFloat(size);\n\n      if (size.endsWith(\"%\")) {\n        return [numeric, \"%\"];\n      } else if (size.endsWith(\"px\")) {\n        return [numeric, \"px\"];\n      } else if (size.endsWith(\"rem\")) {\n        return [numeric, \"rem\"];\n      } else if (size.endsWith(\"em\")) {\n        return [numeric, \"em\"];\n      } else if (size.endsWith(\"vh\")) {\n        return [numeric, \"vh\"];\n      } else if (size.endsWith(\"vw\")) {\n        return [numeric, \"vw\"];\n      }\n\n      return [numeric, \"%\"];\n    }\n  }\n}\n","import { convertEmToPixels } from \"./convertEmToPixels\";\nimport { convertRemToPixels } from \"./convertRemToPixels\";\nimport { convertVhToPixels } from \"./convertVhToPixels\";\nimport { convertVwToPixels } from \"./convertVwToPixels\";\nimport { parseSizeAndUnit } from \"./parseSizeAndUnit\";\n\nexport function sizeStyleToPixels({\n  groupSize,\n  panelElement,\n  styleProp\n}: {\n  groupSize: number;\n  panelElement: HTMLElement;\n  styleProp: number | string;\n}) {\n  let pixels: number | undefined = undefined;\n\n  const [size, unit] = parseSizeAndUnit(styleProp);\n\n  switch (unit) {\n    case \"%\": {\n      pixels = (size / 100) * groupSize;\n      break;\n    }\n    case \"px\": {\n      pixels = size;\n      break;\n    }\n    case \"rem\": {\n      pixels = convertRemToPixels(panelElement, size);\n      break;\n    }\n    case \"em\": {\n      pixels = convertEmToPixels(panelElement, size);\n      break;\n    }\n    case \"vh\": {\n      pixels = convertVhToPixels(size);\n      break;\n    }\n    case \"vw\": {\n      pixels = convertVwToPixels(size);\n      break;\n    }\n  }\n\n  return pixels;\n}\n","export function formatLayoutNumber(number: number) {\n  return parseFloat(number.toFixed(3));\n}\n","import type { RegisteredGroup } from \"../../components/group/types\";\nimport type { PanelConstraints } from \"../../components/panel/types\";\nimport { sizeStyleToPixels } from \"../styles/sizeStyleToPixels\";\nimport { formatLayoutNumber } from \"../utils/formatLayoutNumber\";\nimport { calculateAvailableGroupSize } from \"./calculateAvailableGroupSize\";\n\nexport function calculatePanelConstraints(group: RegisteredGroup) {\n  const { panels } = group;\n\n  const groupSize = calculateAvailableGroupSize({ group });\n  if (groupSize === 0) {\n    // Can't calculate anything meaningful if the group has a width/height of 0\n    // (This could indicate that it's within a hidden subtree)\n    return panels.map((current) => ({\n      collapsedSize: 0,\n      collapsible: current.panelConstraints.collapsible === true,\n      defaultSize: undefined,\n      minSize: 0,\n      maxSize: 100,\n      panelId: current.id\n    }));\n  }\n\n  return panels.map<PanelConstraints>((panel) => {\n    const { element, panelConstraints } = panel;\n\n    let collapsedSize = 0;\n    if (panelConstraints.collapsedSize !== undefined) {\n      const pixels = sizeStyleToPixels({\n        groupSize,\n        panelElement: element,\n        styleProp: panelConstraints.collapsedSize\n      });\n\n      collapsedSize = formatLayoutNumber((pixels / groupSize) * 100);\n    }\n\n    let defaultSize: number | undefined = undefined;\n    if (panelConstraints.defaultSize !== undefined) {\n      const pixels = sizeStyleToPixels({\n        groupSize,\n        panelElement: element,\n        styleProp: panelConstraints.defaultSize\n      });\n\n      defaultSize = formatLayoutNumber((pixels / groupSize) * 100);\n    }\n\n    let minSize = 0;\n    if (panelConstraints.minSize !== undefined) {\n      const pixels = sizeStyleToPixels({\n        groupSize,\n        panelElement: element,\n        styleProp: panelConstraints.minSize\n      });\n\n      minSize = formatLayoutNumber((pixels / groupSize) * 100);\n    }\n\n    let maxSize = 100;\n    if (panelConstraints.maxSize !== undefined) {\n      const pixels = sizeStyleToPixels({\n        groupSize,\n        panelElement: element,\n        styleProp: panelConstraints.maxSize\n      });\n\n      maxSize = formatLayoutNumber((pixels / groupSize) * 100);\n    }\n\n    return {\n      collapsedSize,\n      collapsible: panelConstraints.collapsible === true,\n      defaultSize,\n      minSize,\n      maxSize,\n      panelId: panel.id\n    };\n  });\n}\n","export type EventMap = {\n  [key: string]: unknown;\n};\n\nexport type EventListener<Data> = (data: Data) => void;\n\nexport class EventEmitter<Events extends EventMap> {\n  #listenerMap: {\n    [Key in keyof Events]?: EventListener<Events[Key]>[];\n  } = {};\n\n  addListener<Type extends keyof Events>(\n    type: Type,\n    listener: EventListener<Events[Type]>\n  ) {\n    const listeners = this.#listenerMap[type];\n    if (listeners === undefined) {\n      this.#listenerMap[type] = [listener];\n    } else {\n      if (!listeners.includes(listener)) {\n        listeners.push(listener);\n      }\n    }\n\n    return () => {\n      this.removeListener(type, listener);\n    };\n  }\n\n  emit<Type extends keyof Events>(type: Type, data: Events[Type]) {\n    const listeners = this.#listenerMap[type];\n    if (listeners !== undefined) {\n      if (listeners.length === 1) {\n        const listener = listeners[0];\n        listener.call(null, data);\n      } else {\n        let didThrow = false;\n        let caughtError = null;\n\n        // Clone the current listeners before calling\n        // in case calling triggers listeners to be added or removed\n        const clonedListeners = Array.from(listeners);\n        for (let i = 0; i < clonedListeners.length; i++) {\n          const listener = clonedListeners[i];\n          try {\n            listener.call(null, data);\n          } catch (error) {\n            if (caughtError === null) {\n              didThrow = true;\n              caughtError = error;\n            }\n          }\n        }\n\n        if (didThrow) {\n          throw caughtError;\n        }\n      }\n    }\n  }\n\n  removeAllListeners() {\n    this.#listenerMap = {};\n  }\n\n  removeListener<Type extends keyof Events>(\n    type: Type,\n    listener: EventListener<Events[Type]>\n  ) {\n    const listeners = this.#listenerMap[type];\n    if (listeners !== undefined) {\n      const index = listeners.indexOf(listener);\n      if (index >= 0) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n}\n","import { formatLayoutNumber } from \"./formatLayoutNumber\";\n\nexport function layoutNumbersEqual(\n  actual: number,\n  expected: number,\n  minimumDelta = 0\n) {\n  return (\n    Math.abs(formatLayoutNumber(actual) - formatLayoutNumber(expected)) <=\n    minimumDelta\n  );\n}\n","import type { Layout, RegisteredGroup } from \"../components/group/types\";\nimport type {\n  PanelConstraints,\n  RegisteredPanel\n} from \"../components/panel/types\";\nimport type { RegisteredSeparator } from \"../components/separator/types\";\nimport { EventEmitter } from \"../utils/EventEmitter\";\nimport type { InteractionState } from \"./types\";\nimport { layoutNumbersEqual } from \"./utils/layoutNumbersEqual\";\n\ntype UpdaterFunction = (prevState: State) => Partial<State>;\n\nexport type SeparatorToPanelsMap = Map<\n  RegisteredSeparator,\n  [primaryPanel: RegisteredPanel, secondaryPanel: RegisteredPanel]\n>;\n\nexport type MountedGroupMap = Map<\n  RegisteredGroup,\n  {\n    defaultLayoutDeferred: boolean;\n    derivedPanelConstraints: PanelConstraints[];\n    layout: Layout;\n    separatorToPanels: SeparatorToPanelsMap;\n  }\n>;\n\ntype Events = {\n  cursorFlagsChange: number;\n  interactionStateChange: InteractionState;\n  mountedGroupsChange: MountedGroupMap;\n};\n\ntype State = {\n  cursorFlags: number;\n  interactionState: InteractionState;\n  mountedGroups: MountedGroupMap;\n};\n\nlet state: State = {\n  cursorFlags: 0,\n  interactionState: {\n    state: \"inactive\"\n  },\n  mountedGroups: new Map()\n};\n\nexport const eventEmitter = new EventEmitter<Events>();\n\nexport function read(): State {\n  return state;\n}\n\nexport function update(value: Partial<State> | UpdaterFunction) {\n  const partialState = typeof value === \"function\" ? value(state) : value;\n  if (state === partialState) {\n    return state;\n  }\n\n  const prevState = state;\n\n  state = {\n    ...state,\n    ...partialState\n  };\n\n  if (partialState.cursorFlags !== undefined) {\n    eventEmitter.emit(\"cursorFlagsChange\", state.cursorFlags);\n  }\n\n  if (partialState.interactionState !== undefined) {\n    eventEmitter.emit(\"interactionStateChange\", state.interactionState);\n  }\n\n  if (partialState.mountedGroups !== undefined) {\n    // If any collapsible Panels have been collapsed by this size change, record their previous sizes\n    state.mountedGroups.forEach((value, group) => {\n      value.derivedPanelConstraints.forEach((constraints) => {\n        if (constraints.collapsible) {\n          const { layout: prevLayout } =\n            prevState.mountedGroups.get(group) ?? {};\n          if (prevLayout) {\n            const isCollapsed = layoutNumbersEqual(\n              constraints.collapsedSize,\n              value.layout[constraints.panelId]\n            );\n            const wasCollapsed = layoutNumbersEqual(\n              constraints.collapsedSize,\n              prevLayout[constraints.panelId]\n            );\n            if (isCollapsed && !wasCollapsed) {\n              group.inMemoryLastExpandedPanelSizes[constraints.panelId] =\n                prevLayout[constraints.panelId];\n            }\n          }\n        }\n      });\n    });\n\n    eventEmitter.emit(\"mountedGroupsChange\", state.mountedGroups);\n  }\n\n  return state;\n}\n","import type { Orientation } from \"../../components/group/types\";\nimport type { Point } from \"../../types\";\nimport type { HitRegion } from \"../dom/calculateHitRegions\";\nimport { getDistanceBetweenPointAndRect } from \"./getDistanceBetweenPointAndRect\";\n\nexport function findClosestHitRegion(\n  orientation: Orientation,\n  hitRegions: HitRegion[],\n  point: Point\n) {\n  let closestHitRegion: HitRegion | undefined = undefined;\n  let minDistance = {\n    x: Infinity,\n    y: Infinity\n  };\n\n  for (const hitRegion of hitRegions) {\n    const data = getDistanceBetweenPointAndRect(point, hitRegion.rect);\n    switch (orientation) {\n      case \"horizontal\": {\n        if (data.x <= minDistance.x) {\n          closestHitRegion = hitRegion;\n          minDistance = data;\n        }\n        break;\n      }\n      case \"vertical\": {\n        if (data.y <= minDistance.y) {\n          closestHitRegion = hitRegion;\n          minDistance = data;\n        }\n        break;\n      }\n    }\n  }\n\n  return closestHitRegion\n    ? {\n        distance: minDistance,\n        hitRegion: closestHitRegion\n      }\n    : undefined;\n}\n","// Detects ShadowRoot without requiring instanceof and browser globals\nexport function isShadowRoot(value: unknown): value is ShadowRoot {\n  return (\n    value !== null &&\n    typeof value === \"object\" &&\n    \"nodeType\" in value &&\n    value.nodeType === Node.DOCUMENT_FRAGMENT_NODE\n  );\n}\n","// Forked from NPM stacking-order@2.0.0\n// - github.com/Rich-Harris/stacking-order/issues/3\n// - github.com/Rich-Harris/stacking-order/issues/6\n\nimport { assert } from \"../utils/assert\";\nimport { isShadowRoot } from \"../utils/isShadowRoot\";\n\n/**\n * Determine which of two nodes appears in front of the other —\n * if `a` is in front, returns 1, otherwise returns -1\n * @param {HTMLElement | SVGElement} a\n * @param {HTMLElement | SVGElement} b\n */\nexport function compare(\n  a: HTMLElement | SVGElement,\n  b: HTMLElement | SVGElement\n): number {\n  if (a === b) throw new Error(\"Cannot compare node with itself\");\n\n  const ancestors = {\n    a: get_ancestors(a),\n    b: get_ancestors(b)\n  };\n\n  let common_ancestor;\n\n  // remove shared ancestors\n  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {\n    a = ancestors.a.pop() as HTMLElement;\n    b = ancestors.b.pop() as HTMLElement;\n\n    common_ancestor = a;\n  }\n\n  assert(\n    common_ancestor,\n    \"Stacking order can only be calculated for elements with a common ancestor\"\n  );\n\n  const z_indexes = {\n    a: get_z_index(find_stacking_context(ancestors.a)),\n    b: get_z_index(find_stacking_context(ancestors.b))\n  };\n\n  if (z_indexes.a === z_indexes.b) {\n    const children = common_ancestor.childNodes;\n\n    const furthest_ancestors = {\n      a: ancestors.a.at(-1),\n      b: ancestors.b.at(-1)\n    };\n\n    let i = children.length;\n    while (i--) {\n      const child = children[i];\n      if (child === furthest_ancestors.a) return 1;\n      if (child === furthest_ancestors.b) return -1;\n    }\n  }\n\n  return Math.sign(z_indexes.a - z_indexes.b);\n}\n\nconst props =\n  /\\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\\b/;\n\n/** @param {HTMLElement | SVGElement} node */\nfunction is_flex_item(node: HTMLElement | SVGElement) {\n  // @ts-expect-error ParentNode vs Element\n  const display = getComputedStyle(get_parent(node) ?? node).display;\n  return display === \"flex\" || display === \"inline-flex\";\n}\n\n/** @param {HTMLElement | SVGElement} node */\nfunction creates_stacking_context(node: HTMLElement | SVGElement) {\n  const style = getComputedStyle(node);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n  if (style.position === \"fixed\") return true;\n  // Forked to fix upstream bug https://github.com/Rich-Harris/stacking-order/issues/3\n  // if (\n  //   (style.zIndex !== \"auto\" && style.position !== \"static\") ||\n  //   is_flex_item(node)\n  // )\n  if (\n    style.zIndex !== \"auto\" &&\n    (style.position !== \"static\" || is_flex_item(node))\n  )\n    return true;\n  if (+style.opacity < 1) return true;\n  if (\"transform\" in style && style.transform !== \"none\") return true;\n  if (\"webkitTransform\" in style && style.webkitTransform !== \"none\")\n    return true;\n  if (\"mixBlendMode\" in style && style.mixBlendMode !== \"normal\") return true;\n  if (\"filter\" in style && style.filter !== \"none\") return true;\n  if (\"webkitFilter\" in style && style.webkitFilter !== \"none\") return true;\n  if (\"isolation\" in style && style.isolation === \"isolate\") return true;\n  if (props.test(style.willChange)) return true;\n  // @ts-expect-error Unrecognized prop\n  if (style.webkitOverflowScrolling === \"touch\") return true;\n\n  return false;\n}\n\n/** @param {(HTMLElement| SVGElement)[]} nodes */\nfunction find_stacking_context(nodes: (HTMLElement | SVGElement)[]) {\n  let i = nodes.length;\n\n  while (i--) {\n    const node = nodes[i];\n    assert(node, \"Missing node\");\n    if (creates_stacking_context(node)) return node;\n  }\n\n  return null;\n}\n\n/** @param {HTMLElement | SVGElement} node */\nfunction get_z_index(node: HTMLElement | SVGElement | null) {\n  return (node && Number(getComputedStyle(node).zIndex)) || 0;\n}\n\n/** @param {HTMLElement} node */\nfunction get_ancestors(node: HTMLElement | SVGElement | null) {\n  const ancestors = [];\n\n  while (node) {\n    ancestors.push(node);\n    // @ts-expect-error ParentNode vs Element\n    node = get_parent(node);\n  }\n\n  return ancestors; // [ node, ... <body>, <html>, document ]\n}\n\n/** @param {HTMLElement} node */\nfunction get_parent(node: HTMLElement) {\n  const { parentNode } = node;\n  if (isShadowRoot(parentNode)) {\n    return parentNode.host;\n  }\n  return parentNode;\n}\n","import type { Rect } from \"../../types\";\n\nexport function doRectsIntersect(a: Rect, b: Rect): boolean {\n  return (\n    a.x < b.x + b.width &&\n    a.x + a.width > b.x &&\n    a.y < b.y + b.height &&\n    a.y + a.height > b.y\n  );\n}\n","import { isHTMLElement } from \"../../utils/isHTMLElement\";\nimport { compare } from \"../../vendor/stacking-order\";\nimport { doRectsIntersect } from \"./doRectsIntersect\";\n\n// This library adds pointer event handlers to the Window for two reasons:\n// 1. It allows detecting when the pointer is \"near\" to a panel border or separator element,\n//    (which can be particularly helpful on touch devices)\n// 2. It allows detecting pointer interactions that apply to multiple, nearby panels/separators\n//    (in the event of e.g. nested groups)\n//\n// Because events are handled at the Window, it's important to detect when another element is \"above\" a separator (e.g. a modal)\n// as this should prevent the separator element from being clicked.\n// This function does that determination.\nexport function isViableHitTarget({\n  groupElement,\n  hitRegion,\n  pointerEventTarget\n}: {\n  groupElement: HTMLElement;\n  hitRegion: DOMRect;\n  pointerEventTarget: EventTarget | null;\n}) {\n  if (\n    !isHTMLElement(pointerEventTarget) ||\n    pointerEventTarget.contains(groupElement) ||\n    groupElement.contains(pointerEventTarget)\n  ) {\n    // Calculating stacking order has a cost;\n    // If either group or element contain the other, the click is safe and we can skip calculating the indices\n    return true;\n  }\n\n  if (compare(pointerEventTarget, groupElement) > 0) {\n    // If the pointer target is above the separator, check for overlap\n    // If they are near each other, but not overlapping, then the separator is still a viable target\n    //\n    // Note that it's not sufficient to compare only the target\n    // The target might be a small element inside of a larger container\n    // (For example, a SPAN or a DIV inside of a larger modal dialog)\n    let currentElement: HTMLElement | SVGElement | null = pointerEventTarget;\n    while (currentElement) {\n      if (currentElement.contains(groupElement)) {\n        return true;\n      } else if (\n        doRectsIntersect(currentElement.getBoundingClientRect(), hitRegion)\n      ) {\n        return false;\n      }\n\n      currentElement = currentElement.parentElement;\n    }\n  }\n\n  return true;\n}\n","import {\n  calculateHitRegions,\n  type HitRegion\n} from \"../dom/calculateHitRegions\";\nimport type { MountedGroupMap } from \"../mutableState\";\nimport { findClosestHitRegion } from \"./findClosestHitRegion\";\nimport { isViableHitTarget } from \"./isViableHitTarget\";\n\nexport function findMatchingHitRegions(\n  event: {\n    clientX: number;\n    clientY: number;\n    target: EventTarget | null;\n  },\n  mountedGroups: MountedGroupMap\n): HitRegion[] {\n  const matchingHitRegions: HitRegion[] = [];\n\n  mountedGroups.forEach((_, groupData) => {\n    if (groupData.disabled) {\n      return;\n    }\n\n    const hitRegions = calculateHitRegions(groupData);\n    const match = findClosestHitRegion(groupData.orientation, hitRegions, {\n      x: event.clientX,\n      y: event.clientY\n    });\n    if (\n      match &&\n      match.distance.x <= 0 &&\n      match.distance.y <= 0 &&\n      isViableHitTarget({\n        groupElement: groupData.element,\n        hitRegion: match.hitRegion.rect,\n        pointerEventTarget: event.target\n      })\n    ) {\n      matchingHitRegions.push(match.hitRegion);\n    }\n  });\n\n  return matchingHitRegions;\n}\n","export function isArrayEqual(a: number[], b: number[]) {\n  if (a.length !== b.length) {\n    return false;\n  } else {\n    for (let index = 0; index < a.length; index++) {\n      if (a[index] != b[index]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n","import { layoutNumbersEqual } from \"./layoutNumbersEqual\";\n\nexport function compareLayoutNumbers(actual: number, expected: number) {\n  if (layoutNumbersEqual(actual, expected)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\n","import type { PanelConstraints } from \"../../components/panel/types\";\nimport { compareLayoutNumbers } from \"./compareLayoutNumbers\";\nimport { formatLayoutNumber } from \"./formatLayoutNumber\";\n\n// Panel size must be in percentages; pixel values should be pre-converted\nexport function validatePanelSize({\n  panelConstraints,\n  size\n}: {\n  panelConstraints: PanelConstraints;\n  size: number;\n}) {\n  const {\n    collapsedSize = 0,\n    collapsible,\n    maxSize = 100,\n    minSize = 0\n  } = panelConstraints;\n\n  if (compareLayoutNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (compareLayoutNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n\n  size = Math.min(maxSize, size);\n  size = formatLayoutNumber(size);\n\n  return size;\n}\n","import type { Layout } from \"../../components/group/types\";\nimport type { PanelConstraints } from \"../../components/panel/types\";\nimport { assert } from \"../../utils/assert\";\nimport { isArrayEqual } from \"../../utils/isArrayEqual\";\nimport { compareLayoutNumbers } from \"../utils/compareLayoutNumbers\";\nimport { layoutNumbersEqual } from \"../utils/layoutNumbersEqual\";\nimport { validatePanelSize } from \"../utils/validatePanelSize\";\n\n// All units must be in percentages; pixel values should be pre-converted\nexport function adjustLayoutByDelta({\n  delta,\n  initialLayout: initialLayoutProp,\n  panelConstraints: panelConstraintsArray,\n  pivotIndices,\n  prevLayout: prevLayoutProp,\n  trigger\n}: {\n  delta: number;\n  initialLayout: Layout;\n  panelConstraints: PanelConstraints[];\n  pivotIndices: number[];\n  prevLayout: Layout;\n  trigger: \"imperative-api\" | \"keyboard\" | \"mouse-or-touch\";\n}): Layout {\n  if (layoutNumbersEqual(delta, 0)) {\n    return initialLayoutProp;\n  }\n\n  const initialLayout = Object.values(initialLayoutProp);\n  const prevLayout = Object.values(prevLayoutProp);\n  const nextLayout = [...initialLayout];\n\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  assert(firstPivotIndex != null, \"Invalid first pivot index\");\n  assert(secondPivotIndex != null, \"Invalid second pivot index\");\n\n  let deltaApplied = 0;\n\n  // const DEBUG = [];\n  // DEBUG.push(`adjustLayoutByDelta()`);\n  // DEBUG.push(`  initialLayout: ${initialLayout.join(\", \")}`);\n  // DEBUG.push(`  prevLayout: ${prevLayout.join(\", \")}`);\n  // DEBUG.push(`  delta: ${delta}`);\n  // DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n  // DEBUG.push(`  trigger: ${trigger}`);\n  // DEBUG.push(\"\");\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel(s) immediately after the separator should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel(s) immediately before the separator should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the separator.\n\n  {\n    // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n    // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n    if (trigger === \"keyboard\") {\n      {\n        // Check if we should expand a collapsed panel\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(\n          panelConstraints,\n          `Panel constraints not found for index ${index}`\n        );\n\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 1: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(\n            prevSize != null,\n            `Previous layout not found for panel index ${index}`\n          );\n\n          if (layoutNumbersEqual(prevSize, collapsedSize)) {\n            const localDelta = minSize - prevSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (compareLayoutNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n\n      {\n        // Check if we should collapse a panel at its minimum size\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(\n          panelConstraints,\n          `No panel constraints found for index ${index}`\n        );\n\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 2: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(\n            prevSize != null,\n            `Previous layout not found for panel index ${index}`\n          );\n\n          if (layoutNumbersEqual(prevSize, minSize)) {\n            const localDelta = prevSize - collapsedSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (compareLayoutNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n    }\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Pre-calculate max available delta in the opposite direction of our pivot.\n    // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n    // If this amount is less than the requested delta, adjust the requested delta.\n    // If this amount is greater than the requested delta, that's useful information too–\n    // as an expanding panel might change from collapsed to min size.\n\n    const increment = delta < 0 ? 1 : -1;\n\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n\n    // DEBUG.push(\"pre calc...\");\n    while (true) {\n      const prevSize = initialLayout[index];\n      assert(\n        prevSize != null,\n        `Previous layout not found for panel index ${index}`\n      );\n\n      const maxSafeSize = validatePanelSize({\n        panelConstraints: panelConstraintsArray[index],\n        size: 100\n      });\n      const delta = maxSafeSize - prevSize;\n      // DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n\n      maxAvailableDelta += delta;\n      index += increment;\n\n      if (index < 0 || index >= panelConstraintsArray.length) {\n        break;\n      }\n    }\n\n    // DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    // DEBUG.push(`  -> adjusted delta: ${delta}`);\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panelConstraintsArray.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n\n      const prevSize = initialLayout[index];\n      assert(\n        prevSize != null,\n        `Previous layout not found for panel index ${index}`\n      );\n\n      const unsafeSize = prevSize - deltaRemaining;\n      const safeSize = validatePanelSize({\n        panelConstraints: panelConstraintsArray[index],\n        size: unsafeSize\n      });\n\n      if (!layoutNumbersEqual(prevSize, safeSize)) {\n        deltaApplied += prevSize - safeSize;\n\n        nextLayout[index] = safeSize;\n\n        if (\n          deltaApplied\n            .toFixed(3)\n            .localeCompare(Math.abs(delta).toFixed(3), undefined, {\n              numeric: true\n            }) >= 0\n        ) {\n          break;\n        }\n      }\n\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  // DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n  if (isArrayEqual(prevLayout, nextLayout)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayoutProp;\n  }\n\n  {\n    // Now distribute the applied delta to the panels in the other direction\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n\n    const prevSize = initialLayout[pivotIndex];\n    assert(\n      prevSize != null,\n      `Previous layout not found for panel index ${pivotIndex}`\n    );\n\n    const unsafeSize = prevSize + deltaApplied;\n    const safeSize = validatePanelSize({\n      panelConstraints: panelConstraintsArray[pivotIndex],\n      size: unsafeSize\n    });\n\n    // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n    nextLayout[pivotIndex] = safeSize;\n\n    // Edge case where expanding or contracting one panel caused another one to change collapsed state\n    if (!layoutNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n\n      const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex;\n      while (index >= 0 && index < panelConstraintsArray.length) {\n        const prevSize = nextLayout[index];\n        assert(\n          prevSize != null,\n          `Previous layout not found for panel index ${index}`\n        );\n\n        const unsafeSize = prevSize + deltaRemaining;\n        const safeSize = validatePanelSize({\n          panelConstraints: panelConstraintsArray[index],\n          size: unsafeSize\n        });\n\n        if (!layoutNumbersEqual(prevSize, safeSize)) {\n          deltaRemaining -= safeSize - prevSize;\n\n          nextLayout[index] = safeSize;\n        }\n\n        if (layoutNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  // DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  const totalSize = Object.values(nextLayout).reduce(\n    (total, size) => size + total,\n    0\n  );\n  // DEBUG.push(`total size: ${totalSize}`);\n\n  // If our new layout doesn't add up to 100%, that means the requested delta can't be applied\n  // In that case, fall back to our most recent valid layout\n  // Allow for a small rounding difference, else e.g. 3 panel layouts may never be considered valid\n  if (!layoutNumbersEqual(totalSize, 100, 0.1)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayoutProp;\n  }\n\n  const prevLayoutKeys = Object.keys(prevLayoutProp);\n\n  // console.log(DEBUG.join(\"\\n\"));\n  return nextLayout.reduce<Layout>((accumulated, current, index) => {\n    accumulated[prevLayoutKeys[index]] = current;\n    return accumulated;\n  }, {});\n}\n","import type { Layout } from \"../../components/group/types\";\nimport { compareLayoutNumbers } from \"./compareLayoutNumbers\";\n\nexport function layoutsEqual(a: Layout, b: Layout): boolean {\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n\n  for (const id in a) {\n    // Edge case: Panel id has been changed\n    if (b[id] === undefined || compareLayoutNumbers(a[id], b[id]) !== 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type { Layout } from \"../../components/group/types\";\nimport type { PanelConstraints } from \"../../components/panel/types\";\nimport { assert } from \"../../utils/assert\";\nimport { layoutNumbersEqual } from \"./layoutNumbersEqual\";\nimport { validatePanelSize } from \"./validatePanelSize\";\n\n// All units must be in percentages; pixel values should be pre-converted\nexport function validatePanelGroupLayout({\n  layout,\n  panelConstraints\n}: {\n  layout: Layout;\n  panelConstraints: PanelConstraints[];\n}): Layout {\n  const prevLayout = Object.values(layout);\n  const nextLayout = [...prevLayout];\n\n  const nextLayoutTotalSize = nextLayout.reduce(\n    (accumulated, current) => accumulated + current,\n    0\n  );\n\n  // Validate layout expectations\n  if (nextLayout.length !== panelConstraints.length) {\n    throw Error(\n      `Invalid ${panelConstraints.length} panel layout: ${nextLayout\n        .map((size) => `${size}%`)\n        .join(\", \")}`\n    );\n  } else if (\n    !layoutNumbersEqual(nextLayoutTotalSize, 100) &&\n    nextLayout.length > 0\n  ) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const unsafeSize = nextLayout[index];\n      assert(unsafeSize != null, `No layout data found for index ${index}`);\n      const safeSize = (100 / nextLayoutTotalSize) * unsafeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  let remainingSize = 0;\n\n  // First pass: Validate the proposed layout given each panel's constraints\n  for (let index = 0; index < panelConstraints.length; index++) {\n    const unsafeSize = nextLayout[index];\n    assert(unsafeSize != null, `No layout data found for index ${index}`);\n\n    const safeSize = validatePanelSize({\n      panelConstraints: panelConstraints[index],\n      size: unsafeSize\n    });\n\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (!layoutNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const prevSize = nextLayout[index];\n      assert(prevSize != null, `No layout data found for index ${index}`);\n      const unsafeSize = prevSize + remainingSize;\n      const safeSize = validatePanelSize({\n        panelConstraints: panelConstraints[index],\n        size: unsafeSize\n      });\n\n      if (prevSize !== safeSize) {\n        remainingSize -= safeSize - prevSize;\n        nextLayout[index] = safeSize;\n\n        // Once we've used up the remainder, bail\n        if (layoutNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n\n  const prevLayoutKeys = Object.keys(layout);\n\n  return nextLayout.reduce<Layout>((accumulated, current, index) => {\n    accumulated[prevLayoutKeys[index]] = current;\n    return accumulated;\n  }, {});\n}\n","import type { PanelImperativeHandle } from \"../../components/panel/types\";\nimport { calculateAvailableGroupSize } from \"../dom/calculateAvailableGroupSize\";\nimport { read, update } from \"../mutableState\";\nimport { adjustLayoutByDelta } from \"./adjustLayoutByDelta\";\nimport { formatLayoutNumber } from \"./formatLayoutNumber\";\nimport { layoutNumbersEqual } from \"./layoutNumbersEqual\";\nimport { layoutsEqual } from \"./layoutsEqual\";\nimport { validatePanelGroupLayout } from \"./validatePanelGroupLayout\";\n\nexport function getImperativePanelMethods({\n  groupId,\n  panelId\n}: {\n  groupId: string;\n  panelId: string;\n}): PanelImperativeHandle {\n  const find = () => {\n    const { mountedGroups } = read();\n    for (const [\n      group,\n      {\n        defaultLayoutDeferred,\n        derivedPanelConstraints,\n        layout,\n        separatorToPanels\n      }\n    ] of mountedGroups) {\n      if (group.id === groupId) {\n        return {\n          defaultLayoutDeferred,\n          derivedPanelConstraints,\n          group,\n          layout,\n          separatorToPanels\n        };\n      }\n    }\n\n    throw Error(`Group ${groupId} not found`);\n  };\n\n  const getPanelConstraints = () => {\n    const match = find().derivedPanelConstraints.find(\n      (current) => current.panelId === panelId\n    );\n    if (match !== undefined) {\n      return match;\n    }\n\n    throw Error(`Panel constraints not found for Panel ${panelId}`);\n  };\n\n  const getPanel = () => {\n    const match = find().group.panels.find((current) => current.id === panelId);\n    if (match !== undefined) {\n      return match;\n    }\n\n    throw Error(`Layout not found for Panel ${panelId}`);\n  };\n\n  const getPanelSize = () => {\n    const match = find().layout[panelId];\n    if (match !== undefined) {\n      return match;\n    }\n\n    throw Error(`Layout not found for Panel ${panelId}`);\n  };\n\n  const setPanelSize = (nextSize: number) => {\n    const prevSize = getPanelSize();\n    if (nextSize === prevSize) {\n      return;\n    }\n\n    const {\n      defaultLayoutDeferred,\n      derivedPanelConstraints,\n      group,\n      layout: prevLayout,\n      separatorToPanels\n    } = find();\n\n    const index = group.panels.findIndex((current) => current.id === panelId);\n    const isLastPanel = index === group.panels.length - 1;\n\n    const unsafeLayout = adjustLayoutByDelta({\n      delta: isLastPanel ? prevSize - nextSize : nextSize - prevSize,\n      initialLayout: prevLayout,\n      panelConstraints: derivedPanelConstraints,\n      pivotIndices: isLastPanel ? [index - 1, index] : [index, index + 1],\n      prevLayout,\n      trigger: \"imperative-api\"\n    });\n\n    const nextLayout = validatePanelGroupLayout({\n      layout: unsafeLayout,\n      panelConstraints: derivedPanelConstraints\n    });\n    if (!layoutsEqual(prevLayout, nextLayout)) {\n      update((prevState) => ({\n        mountedGroups: new Map(prevState.mountedGroups).set(group, {\n          defaultLayoutDeferred,\n          derivedPanelConstraints,\n          layout: nextLayout,\n          separatorToPanels\n        })\n      }));\n    }\n  };\n\n  return {\n    collapse: () => {\n      const { collapsible, collapsedSize } = getPanelConstraints();\n      const { mutableValues } = getPanel();\n      const size = getPanelSize();\n\n      if (collapsible && size !== collapsedSize) {\n        // Store previous size in to restore if expand() is called\n        mutableValues.expandToSize = size;\n\n        setPanelSize(collapsedSize);\n      }\n    },\n    expand: () => {\n      const { collapsible, collapsedSize, minSize } = getPanelConstraints();\n      const { mutableValues } = getPanel();\n      const size = getPanelSize();\n\n      if (collapsible && size === collapsedSize) {\n        // Restore pre-collapse size, fallback to minSize\n        let nextSize = mutableValues.expandToSize ?? minSize;\n\n        // Edge case: if minSize is 0, pick something meaningful to expand the panel to\n        if (nextSize === 0) {\n          nextSize = 1;\n        }\n\n        setPanelSize(nextSize);\n      }\n    },\n    getSize: () => {\n      const { group } = find();\n      const asPercentage = getPanelSize();\n      const { element } = getPanel();\n\n      const inPixels =\n        group.orientation === \"horizontal\"\n          ? element.offsetWidth\n          : element.offsetHeight;\n\n      return {\n        asPercentage,\n        inPixels\n      };\n    },\n    isCollapsed: () => {\n      const { collapsible, collapsedSize } = getPanelConstraints();\n      const size = getPanelSize();\n\n      return collapsible && layoutNumbersEqual(collapsedSize, size);\n    },\n    resize: (size: number | string) => {\n      const prevSize = getPanelSize();\n      if (prevSize !== size) {\n        let asPercentage;\n        switch (typeof size) {\n          case \"number\": {\n            const { group } = find();\n            const groupSize = calculateAvailableGroupSize({ group });\n            asPercentage = formatLayoutNumber((size / groupSize) * 100);\n            break;\n          }\n          case \"string\": {\n            asPercentage = parseFloat(size);\n            break;\n          }\n        }\n\n        setPanelSize(asPercentage);\n      }\n    }\n  } satisfies PanelImperativeHandle;\n}\n","import type { RegisteredGroup } from \"../../components/group/types\";\nimport type { RegisteredPanel } from \"../../components/panel/types\";\nimport { read } from \"../mutableState\";\nimport { findMatchingHitRegions } from \"../utils/findMatchingHitRegions\";\nimport { getImperativePanelMethods } from \"../utils/getImperativePanelMethods\";\n\nexport function onDocumentDoubleClick(event: MouseEvent) {\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  const { mountedGroups } = read();\n\n  const hitRegions = findMatchingHitRegions(event, mountedGroups);\n\n  const groups = new Set<RegisteredGroup>();\n  const panels = new Set<RegisteredPanel>();\n\n  hitRegions.forEach((current) => {\n    groups.add(current.group);\n    current.panels.forEach((panel) => {\n      panels.add(panel);\n    });\n\n    if (current.separator) {\n      const panelWithDefaultSize = current.panels.find(\n        (panel) => panel.panelConstraints.defaultSize !== undefined\n      );\n      if (panelWithDefaultSize) {\n        const defaultSize = panelWithDefaultSize.panelConstraints.defaultSize;\n        const api = getImperativePanelMethods({\n          groupId: current.group.id,\n          panelId: panelWithDefaultSize.id\n        });\n        if (api && defaultSize !== undefined) {\n          api.resize(defaultSize);\n\n          event.preventDefault();\n        }\n      }\n    }\n  });\n}\n","import { read } from \"../mutableState\";\n\nexport function findSeparatorGroup(separatorElement: HTMLElement) {\n  const { mountedGroups } = read();\n\n  for (const [group] of mountedGroups) {\n    if (\n      group.separators.some(\n        (separator) => separator.element === separatorElement\n      )\n    ) {\n      return group;\n    }\n  }\n\n  throw Error(\"Could not find parent Group for separator element\");\n}\n","import type {\n  GroupImperativeHandle,\n  Layout\n} from \"../../components/group/types\";\nimport { read, update } from \"../mutableState\";\nimport { layoutsEqual } from \"./layoutsEqual\";\nimport { validatePanelGroupLayout } from \"./validatePanelGroupLayout\";\n\nexport function getImperativeGroupMethods({\n  groupId\n}: {\n  groupId: string;\n}): GroupImperativeHandle {\n  const find = () => {\n    const { mountedGroups } = read();\n    for (const [group, value] of mountedGroups) {\n      if (group.id === groupId) {\n        return { group, ...value };\n      }\n    }\n\n    throw Error(`Could not find Group with id \"${groupId}\"`);\n  };\n\n  return {\n    getLayout() {\n      const { defaultLayoutDeferred, layout } = find();\n\n      if (defaultLayoutDeferred) {\n        // This indicates that the Group has not finished mounting yet\n        // Likely because it has been rendered inside of a hidden DOM subtree\n        // Any layout value will not have been validated and so it should not be returned\n        return {};\n      }\n\n      return layout;\n    },\n    setLayout(unsafeLayout: Layout) {\n      const {\n        defaultLayoutDeferred,\n        derivedPanelConstraints,\n        group,\n        layout: prevLayout,\n        separatorToPanels\n      } = find();\n\n      const nextLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: derivedPanelConstraints\n      });\n\n      if (defaultLayoutDeferred) {\n        // This indicates that the Group has not finished mounting yet\n        // Likely because it has been rendered inside of a hidden DOM subtree\n        // In this case we cannot fully validate the layout, so we shouldn't apply it\n        // It's okay to run the validate function above though,\n        // it will still warn about certain types of errors (e.g. wrong number of panels)\n        return prevLayout;\n      }\n\n      if (!layoutsEqual(prevLayout, nextLayout)) {\n        update((prevState) => ({\n          mountedGroups: new Map(prevState.mountedGroups).set(group, {\n            defaultLayoutDeferred,\n            derivedPanelConstraints,\n            layout: nextLayout,\n            separatorToPanels\n          })\n        }));\n      }\n\n      return nextLayout;\n    }\n  };\n}\n","import type { RegisteredGroup } from \"../../components/group/types\";\nimport { assert } from \"../../utils/assert\";\nimport { read } from \"../mutableState\";\n\nexport function getMountedGroup(group: RegisteredGroup) {\n  const { mountedGroups } = read();\n\n  const mountedGroup = mountedGroups.get(group);\n  assert(mountedGroup, `Mounted Group ${group.id} not found`);\n\n  return mountedGroup;\n}\n","import { assert } from \"../../utils/assert\";\nimport { update } from \"../mutableState\";\nimport { adjustLayoutByDelta } from \"./adjustLayoutByDelta\";\nimport { findSeparatorGroup } from \"./findSeparatorGroup\";\nimport { getImperativeGroupMethods } from \"./getImperativeGroupMethods\";\nimport { getMountedGroup } from \"./getMountedGroup\";\nimport { layoutsEqual } from \"./layoutsEqual\";\nimport { validatePanelGroupLayout } from \"./validatePanelGroupLayout\";\n\nexport function adjustLayoutForSeparator(\n  separatorElement: HTMLElement,\n  delta: number\n) {\n  const group = findSeparatorGroup(separatorElement);\n  const mountedGroup = getMountedGroup(group);\n\n  const separator = group.separators.find(\n    (current) => current.element === separatorElement\n  );\n  assert(separator, \"Matching separator not found\");\n\n  const panels = mountedGroup.separatorToPanels.get(separator);\n  assert(panels, \"Matching panels not found\");\n\n  const pivotIndices = panels.map((panel) => group.panels.indexOf(panel));\n\n  const groupAPI = getImperativeGroupMethods({ groupId: group.id });\n  const prevLayout = groupAPI.getLayout();\n\n  const unsafeLayout = adjustLayoutByDelta({\n    delta,\n    initialLayout: prevLayout,\n    panelConstraints: mountedGroup.derivedPanelConstraints,\n    pivotIndices,\n    prevLayout,\n    trigger: \"keyboard\"\n  });\n  const nextLayout = validatePanelGroupLayout({\n    layout: unsafeLayout,\n    panelConstraints: mountedGroup.derivedPanelConstraints\n  });\n\n  if (!layoutsEqual(prevLayout, nextLayout)) {\n    update((prevState) => ({\n      mountedGroups: new Map(prevState.mountedGroups).set(group, {\n        defaultLayoutDeferred: mountedGroup.defaultLayoutDeferred,\n        derivedPanelConstraints: mountedGroup.derivedPanelConstraints,\n        layout: nextLayout,\n        separatorToPanels: mountedGroup.separatorToPanels\n      })\n    }));\n  }\n}\n","import { assert } from \"../../utils/assert\";\nimport { adjustLayoutForSeparator } from \"../utils/adjustLayoutForSeparator\";\nimport { findSeparatorGroup } from \"../utils/findSeparatorGroup\";\nimport { getMountedGroup } from \"../utils/getMountedGroup\";\n\nexport function onDocumentKeyDown(event: KeyboardEvent) {\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  const separatorElement = event.currentTarget as HTMLElement;\n\n  const group = findSeparatorGroup(separatorElement);\n  if (group.disabled) {\n    return;\n  }\n\n  switch (event.key) {\n    case \"ArrowDown\": {\n      event.preventDefault();\n\n      if (group.orientation === \"vertical\") {\n        adjustLayoutForSeparator(separatorElement, 5);\n      }\n      break;\n    }\n    case \"ArrowLeft\": {\n      event.preventDefault();\n\n      if (group.orientation === \"horizontal\") {\n        adjustLayoutForSeparator(separatorElement, -5);\n      }\n      break;\n    }\n    case \"ArrowRight\": {\n      event.preventDefault();\n\n      if (group.orientation === \"horizontal\") {\n        adjustLayoutForSeparator(separatorElement, 5);\n      }\n      break;\n    }\n    case \"ArrowUp\": {\n      event.preventDefault();\n\n      if (group.orientation === \"vertical\") {\n        adjustLayoutForSeparator(separatorElement, -5);\n      }\n      break;\n    }\n    case \"End\": {\n      event.preventDefault();\n\n      // Moves splitter to the position that gives the primary pane its largest allowed size.\n      // This may completely collapse the secondary pane.\n\n      adjustLayoutForSeparator(separatorElement, 100);\n      break;\n    }\n    case \"Enter\": {\n      event.preventDefault();\n\n      // If the primary pane is not collapsed, collapses the pane.\n      // If the pane is collapsed, restores the splitter to its previous position.\n\n      const group = findSeparatorGroup(separatorElement);\n      const { derivedPanelConstraints, layout, separatorToPanels } =\n        getMountedGroup(group);\n\n      const separator = group.separators.find(\n        (current) => current.element === separatorElement\n      );\n      assert(separator, \"Matching separator not found\");\n\n      const panels = separatorToPanels.get(separator);\n      assert(panels, \"Matching panels not found\");\n\n      const primaryPanel = panels[0];\n      const constraints = derivedPanelConstraints.find(\n        (current) => current.panelId === primaryPanel.id\n      );\n      assert(constraints, \"Panel metadata not found\");\n\n      if (constraints.collapsible) {\n        const prevSize = layout[primaryPanel.id];\n\n        const nextSize =\n          constraints.collapsedSize === prevSize\n            ? (group.inMemoryLastExpandedPanelSizes[primaryPanel.id] ??\n              constraints.minSize)\n            : constraints.collapsedSize;\n\n        adjustLayoutForSeparator(separatorElement, nextSize - prevSize);\n      }\n      break;\n    }\n    case \"F6\": {\n      event.preventDefault();\n\n      // Cycle through window panes.\n\n      const group = findSeparatorGroup(separatorElement);\n\n      const separatorElements = group.separators.map(\n        (separator) => separator.element\n      );\n\n      const index = Array.from(separatorElements).findIndex(\n        (current) => current === event.currentTarget\n      );\n      assert(index !== null, \"Index not found\");\n\n      const nextIndex = event.shiftKey\n        ? index > 0\n          ? index - 1\n          : separatorElements.length - 1\n        : index + 1 < separatorElements.length\n          ? index + 1\n          : 0;\n\n      const nextSeparatorElement = separatorElements[nextIndex] as HTMLElement;\n      nextSeparatorElement.focus();\n      break;\n    }\n    case \"Home\": {\n      event.preventDefault();\n\n      // Moves splitter to the position that gives the primary pane its smallest allowed size.\n      // This may completely collapse the primary pane.\n\n      adjustLayoutForSeparator(separatorElement, -100);\n      break;\n    }\n  }\n}\n","import type { Layout, RegisteredGroup } from \"../../components/group/types\";\nimport type { RegisteredPanel } from \"../../components/panel/types\";\nimport type { RegisteredSeparator } from \"../../components/separator/types\";\nimport { read, update } from \"../mutableState\";\nimport { findMatchingHitRegions } from \"../utils/findMatchingHitRegions\";\n\nexport function onDocumentPointerDown(event: PointerEvent) {\n  if (event.defaultPrevented) {\n    return;\n  } else if (event.pointerType === \"mouse\" && event.button > 0) {\n    return;\n  }\n\n  const { mountedGroups } = read();\n\n  const hitRegions = findMatchingHitRegions(event, mountedGroups);\n\n  const groups = new Set<RegisteredGroup>();\n  const panels = new Set<RegisteredPanel>();\n  const separators = new Set<RegisteredSeparator>();\n  const initialLayoutMap = new Map<RegisteredGroup, Layout>();\n\n  let didChangeFocus = false;\n\n  hitRegions.forEach((current) => {\n    groups.add(current.group);\n    current.panels.forEach((panel) => {\n      panels.add(panel);\n    });\n\n    if (current.separator) {\n      separators.add(current.separator);\n\n      if (!didChangeFocus) {\n        didChangeFocus = true;\n\n        current.separator.element.focus();\n      }\n    }\n\n    const match = mountedGroups.get(current.group);\n    if (match) {\n      initialLayoutMap.set(current.group, match.layout);\n    }\n  });\n\n  update({\n    interactionState: {\n      hitRegions,\n      initialLayoutMap,\n      pointerDownAtPoint: { x: event.clientX, y: event.clientY },\n      state: \"active\"\n    }\n  });\n\n  if (hitRegions.length) {\n    event.preventDefault();\n  }\n}\n","// Constants used for memoization\nexport const EMPTY_ARRAY: unknown[] = [];\nexport const EMPTY_DOM_RECT: DOMRectReadOnly = {\n  bottom: 0,\n  height: 0,\n  left: 0,\n  right: 0,\n  toJSON: () => {},\n  top: 0,\n  width: 0,\n  x: 0,\n  y: 0\n};\nexport const EMPTY_OBJECT = {};\nexport const EMPTY_POINT = { x: 0, y: 0 };\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const IDENTITY_FUNCTION = (value: any) => value;\nexport const NOOP_FUNCTION = () => {};\n\n// Cursor flags\nexport const CURSOR_FLAG_HORIZONTAL_MIN = 0b0001;\nexport const CURSOR_FLAG_HORIZONTAL_MAX = 0b0010;\nexport const CURSOR_FLAG_VERTICAL_MIN = 0b0100;\nexport const CURSOR_FLAG_VERTICAL_MAX = 0b1000;\nexport const CURSOR_FLAGS_HORIZONTAL = 0b0011;\nexport const CURSOR_FLAGS_VERTICAL = 0b1100;\n","let cached: boolean | undefined = undefined;\n\nexport function overrideSupportsAdvancedCursorStylesForTesting(\n  override: boolean\n) {\n  cached = override;\n}\n\n/**\n * Caches and returns if advanced cursor CSS styles are supported.\n */\nexport function supportsAdvancedCursorStyles(): boolean {\n  if (cached === undefined) {\n    cached = false;\n\n    if (typeof window !== \"undefined\") {\n      if (\n        window.navigator.userAgent.includes(\"Chrome\") ||\n        window.navigator.userAgent.includes(\"Firefox\")\n      ) {\n        cached = true;\n      }\n    }\n  }\n\n  return cached;\n}\n","import type { Properties } from \"csstype\";\nimport type { RegisteredGroup } from \"../../components/group/types\";\nimport {\n  CURSOR_FLAG_HORIZONTAL_MAX,\n  CURSOR_FLAG_HORIZONTAL_MIN,\n  CURSOR_FLAG_VERTICAL_MAX,\n  CURSOR_FLAG_VERTICAL_MIN\n} from \"../../constants\";\nimport type { InteractionState } from \"../types\";\nimport { supportsAdvancedCursorStyles } from \"./supportsAdvancedCursorStyles\";\n\nexport function getCursorStyle({\n  cursorFlags,\n  groups,\n  state\n}: {\n  cursorFlags: number;\n  groups: RegisteredGroup[];\n  state: InteractionState[\"state\"];\n}): Properties[\"cursor\"] | null {\n  let horizontalCount = 0;\n  let verticalCount = 0;\n\n  switch (state) {\n    case \"active\":\n    case \"hover\": {\n      groups.forEach((group) => {\n        if (group.disableCursor) {\n          return;\n        }\n\n        switch (group.orientation) {\n          case \"horizontal\": {\n            horizontalCount++;\n            break;\n          }\n          case \"vertical\": {\n            verticalCount++;\n            break;\n          }\n        }\n      });\n    }\n  }\n\n  if (horizontalCount === 0 && verticalCount === 0) {\n    return null;\n  }\n\n  switch (state) {\n    case \"active\": {\n      if (cursorFlags) {\n        if (supportsAdvancedCursorStyles()) {\n          const horizontalMin =\n            (cursorFlags & CURSOR_FLAG_HORIZONTAL_MIN) !== 0;\n          const horizontalMax =\n            (cursorFlags & CURSOR_FLAG_HORIZONTAL_MAX) !== 0;\n          const verticalMin = (cursorFlags & CURSOR_FLAG_VERTICAL_MIN) !== 0;\n          const verticalMax = (cursorFlags & CURSOR_FLAG_VERTICAL_MAX) !== 0;\n\n          if (horizontalMin) {\n            if (verticalMin) {\n              return \"se-resize\";\n            } else if (verticalMax) {\n              return \"ne-resize\";\n            } else {\n              return \"e-resize\";\n            }\n          } else if (horizontalMax) {\n            if (verticalMin) {\n              return \"sw-resize\";\n            } else if (verticalMax) {\n              return \"nw-resize\";\n            } else {\n              return \"w-resize\";\n            }\n          } else if (verticalMin) {\n            return \"s-resize\";\n          } else if (verticalMax) {\n            return \"n-resize\";\n          }\n        }\n      }\n      break;\n    }\n  }\n\n  if (supportsAdvancedCursorStyles()) {\n    if (horizontalCount > 0 && verticalCount > 0) {\n      return \"move\";\n    } else if (horizontalCount > 0) {\n      return \"ew-resize\";\n    } else {\n      return \"ns-resize\";\n    }\n  } else {\n    if (horizontalCount > 0 && verticalCount > 0) {\n      return \"grab\";\n    } else if (horizontalCount > 0) {\n      return \"col-resize\";\n    } else {\n      return \"row-resize\";\n    }\n  }\n}\n","import { read } from \"../mutableState\";\nimport { getCursorStyle } from \"./getCursorStyle\";\n\nconst documentToStyleMap = new WeakMap<\n  Document,\n  {\n    prevStyle: string | undefined;\n    styleSheet: CSSStyleSheet;\n  }\n>();\n\nexport function updateCursorStyle(ownerDocument: Document) {\n  // NOTE undefined is not technically a valid value but it has been reported that it is present in some environments (Vite HMR?)\n  // See github.com/bvaughn/react-resizable-panels/issues/559\n  if (\n    ownerDocument.defaultView === null ||\n    ownerDocument.defaultView === undefined\n  ) {\n    return;\n  }\n\n  let { prevStyle, styleSheet } = documentToStyleMap.get(ownerDocument) ?? {};\n\n  if (styleSheet === undefined) {\n    styleSheet = new ownerDocument.defaultView.CSSStyleSheet();\n\n    ownerDocument.adoptedStyleSheets.push(styleSheet);\n  }\n\n  const { cursorFlags, interactionState } = read();\n\n  switch (interactionState.state) {\n    case \"active\":\n    case \"hover\": {\n      const cursorStyle = getCursorStyle({\n        cursorFlags,\n        groups: interactionState.hitRegions.map((current) => current.group),\n        state: interactionState.state\n      });\n\n      const nextStyle = `*, *:hover {cursor: ${cursorStyle} !important; ${interactionState.state === \"active\" ? \"touch-action: none;\" : \"\"} }`;\n      if (prevStyle === nextStyle) {\n        return;\n      }\n\n      prevStyle = nextStyle;\n\n      if (cursorStyle) {\n        if (styleSheet.cssRules.length === 0) {\n          styleSheet.insertRule(nextStyle);\n        } else {\n          styleSheet.replaceSync(nextStyle);\n        }\n      } else if (styleSheet.cssRules.length === 1) {\n        styleSheet.deleteRule(0);\n      }\n      break;\n    }\n    case \"inactive\": {\n      prevStyle = undefined;\n\n      if (styleSheet.cssRules.length === 1) {\n        styleSheet.deleteRule(0);\n      }\n      break;\n    }\n  }\n\n  documentToStyleMap.set(ownerDocument, {\n    prevStyle,\n    styleSheet\n  });\n}\n","import type { Layout, RegisteredGroup } from \"../../components/group/types\";\nimport {\n  CURSOR_FLAG_HORIZONTAL_MAX,\n  CURSOR_FLAG_HORIZONTAL_MIN,\n  CURSOR_FLAG_VERTICAL_MAX,\n  CURSOR_FLAG_VERTICAL_MIN,\n  CURSOR_FLAGS_HORIZONTAL,\n  CURSOR_FLAGS_VERTICAL\n} from \"../../constants\";\nimport type { Point } from \"../../types\";\nimport { updateCursorStyle } from \"../cursor/updateCursorStyle\";\nimport type { HitRegion } from \"../dom/calculateHitRegions\";\nimport { update, type MountedGroupMap } from \"../mutableState\";\nimport { adjustLayoutByDelta } from \"./adjustLayoutByDelta\";\nimport { layoutsEqual } from \"./layoutsEqual\";\n\nexport function updateActiveHitRegions({\n  document,\n  event,\n  hitRegions,\n  initialLayoutMap,\n  mountedGroups,\n  pointerDownAtPoint,\n  prevCursorFlags\n}: {\n  document: Document;\n  event: {\n    clientX: number;\n    clientY: number;\n    movementX: number;\n    movementY: number;\n  };\n  hitRegions: HitRegion[];\n  initialLayoutMap: Map<RegisteredGroup, Layout>;\n  mountedGroups: MountedGroupMap;\n  pointerDownAtPoint?: Point;\n  prevCursorFlags: number;\n}) {\n  let nextCursorFlags = 0;\n\n  const nextMountedGroups = new Map(mountedGroups);\n\n  // Note that HitRegions are frozen once a drag has started\n  // Modify the Group layouts for all matching HitRegions though\n  hitRegions.forEach((current) => {\n    const { group, groupSize } = current;\n    const { disableCursor, orientation, panels } = group;\n\n    let deltaAsPercentage = 0;\n    if (pointerDownAtPoint) {\n      if (orientation === \"horizontal\") {\n        deltaAsPercentage =\n          ((event.clientX - pointerDownAtPoint.x) / groupSize) * 100;\n      } else {\n        deltaAsPercentage =\n          ((event.clientY - pointerDownAtPoint.y) / groupSize) * 100;\n      }\n    } else {\n      if (orientation === \"horizontal\") {\n        deltaAsPercentage = event.clientX < 0 ? -100 : 100;\n      } else {\n        deltaAsPercentage = event.clientY < 0 ? -100 : 100;\n      }\n    }\n\n    const initialLayout = initialLayoutMap.get(group);\n\n    const {\n      defaultLayoutDeferred,\n      derivedPanelConstraints,\n      layout: prevLayout,\n      separatorToPanels\n    } = mountedGroups.get(group) ?? { defaultLayoutDeferred: false };\n    if (\n      derivedPanelConstraints &&\n      initialLayout &&\n      prevLayout &&\n      separatorToPanels\n    ) {\n      const nextLayout = adjustLayoutByDelta({\n        delta: deltaAsPercentage,\n        initialLayout,\n        panelConstraints: derivedPanelConstraints,\n        pivotIndices: current.panels.map((panel) => panels.indexOf(panel)),\n        prevLayout,\n        trigger: \"mouse-or-touch\"\n      });\n\n      if (layoutsEqual(nextLayout, prevLayout)) {\n        if (deltaAsPercentage !== 0 && !disableCursor) {\n          // An unchanged means the cursor has exceeded the allowed bounds\n          switch (orientation) {\n            case \"horizontal\": {\n              nextCursorFlags |=\n                deltaAsPercentage < 0\n                  ? CURSOR_FLAG_HORIZONTAL_MIN\n                  : CURSOR_FLAG_HORIZONTAL_MAX;\n              break;\n            }\n            case \"vertical\": {\n              nextCursorFlags |=\n                deltaAsPercentage < 0\n                  ? CURSOR_FLAG_VERTICAL_MIN\n                  : CURSOR_FLAG_VERTICAL_MAX;\n              break;\n            }\n          }\n        }\n      } else {\n        nextMountedGroups.set(current.group, {\n          defaultLayoutDeferred,\n          derivedPanelConstraints: derivedPanelConstraints,\n          layout: nextLayout,\n          separatorToPanels\n        });\n\n        // Save the most recent layout for this group of panels in-memory\n        // so that layouts will be remembered between different sets of conditionally rendered panels\n        const panelIdsKey = current.group.panels.map(({ id }) => id).join(\",\");\n        current.group.inMemoryLayouts[panelIdsKey] = nextLayout;\n      }\n    }\n  });\n\n  // Edge case\n  // Re-use previous horizontal/vertical cursor flags if there's been no movement since the last event\n  // This accounts for edge cases in browsers like Firefox that sometimes round clientX/clientY values\n  let cursorFlags = 0;\n  if (event.movementX === 0) {\n    cursorFlags |= prevCursorFlags & CURSOR_FLAGS_HORIZONTAL;\n  } else {\n    cursorFlags |= nextCursorFlags & CURSOR_FLAGS_HORIZONTAL;\n  }\n  if (event.movementY === 0) {\n    cursorFlags |= prevCursorFlags & CURSOR_FLAGS_VERTICAL;\n  } else {\n    cursorFlags |= nextCursorFlags & CURSOR_FLAGS_VERTICAL;\n  }\n\n  update({\n    cursorFlags,\n    mountedGroups: nextMountedGroups\n  });\n\n  updateCursorStyle(document);\n}\n","import { read } from \"../mutableState\";\nimport { updateActiveHitRegions } from \"../utils/updateActiveHitRegion\";\n\nexport function onDocumentPointerLeave(event: PointerEvent) {\n  const { cursorFlags, interactionState, mountedGroups } = read();\n\n  switch (interactionState.state) {\n    case \"active\": {\n      updateActiveHitRegions({\n        document: event.currentTarget as Document,\n        event,\n        hitRegions: interactionState.hitRegions,\n        initialLayoutMap: interactionState.initialLayoutMap,\n        mountedGroups,\n        prevCursorFlags: cursorFlags\n      });\n    }\n  }\n}\n","import { updateCursorStyle } from \"../cursor/updateCursorStyle\";\nimport { read, update } from \"../mutableState\";\nimport { findMatchingHitRegions } from \"../utils/findMatchingHitRegions\";\nimport { updateActiveHitRegions } from \"../utils/updateActiveHitRegion\";\n\nexport function onDocumentPointerMove(event: PointerEvent) {\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  const { cursorFlags, interactionState, mountedGroups } = read();\n\n  switch (interactionState.state) {\n    case \"active\": {\n      // Edge case (see #340)\n      // Detect when the pointer has been released outside an iframe on a different domain\n      if (\n        // Skip this check for \"pointerleave\" events, else Firefox triggers a false positive (see #514)\n        event.buttons === 0\n      ) {\n        update((prevState) =>\n          prevState.interactionState.state === \"inactive\"\n            ? prevState\n            : {\n                cursorFlags: 0,\n                interactionState: { state: \"inactive\" }\n              }\n        );\n\n        // Dispatch one more \"change\" event after the interaction state has been reset\n        // Groups use this as a signal to call onLayoutChanged\n        update((prevState) => ({\n          mountedGroups: new Map(prevState.mountedGroups)\n        }));\n\n        return;\n      }\n\n      updateActiveHitRegions({\n        document: event.currentTarget as Document,\n        event,\n        hitRegions: interactionState.hitRegions,\n        initialLayoutMap: interactionState.initialLayoutMap,\n        mountedGroups,\n        pointerDownAtPoint: interactionState.pointerDownAtPoint,\n        prevCursorFlags: cursorFlags\n      });\n      break;\n    }\n    default: {\n      // Update HitRegions if a drag has not been started\n      const hitRegions = findMatchingHitRegions(event, mountedGroups);\n\n      if (hitRegions.length === 0) {\n        if (interactionState.state !== \"inactive\") {\n          update({\n            interactionState: {\n              state: \"inactive\"\n            }\n          });\n        }\n      } else {\n        update({\n          interactionState: {\n            hitRegions,\n            state: \"hover\"\n          }\n        });\n      }\n\n      updateCursorStyle(event.currentTarget as Document);\n      break;\n    }\n  }\n}\n","import { updateCursorStyle } from \"../cursor/updateCursorStyle\";\nimport { read, update } from \"../mutableState\";\n\nexport function onDocumentPointerUp(event: PointerEvent) {\n  if (event.defaultPrevented) {\n    return;\n  } else if (event.pointerType === \"mouse\" && event.button > 0) {\n    return;\n  }\n\n  const { interactionState } = read();\n\n  switch (interactionState.state) {\n    case \"active\": {\n      update({\n        cursorFlags: 0,\n        interactionState: {\n          state: \"inactive\"\n        }\n      });\n\n      if (interactionState.hitRegions.length > 0) {\n        updateCursorStyle(event.currentTarget as Document);\n\n        // Dispatch one more \"change\" event after the interaction state has been reset\n        // Groups use this as a signal to call onLayoutChanged\n        update((prevState) => ({\n          mountedGroups: new Map(prevState.mountedGroups)\n        }));\n\n        event.preventDefault();\n      }\n    }\n  }\n}\n","import type { Layout } from \"../../components/group/types\";\nimport type { PanelConstraints } from \"../../components/panel/types\";\nimport { formatLayoutNumber } from \"./formatLayoutNumber\";\n\nexport function calculateDefaultLayout(\n  derivedPanelConstraints: PanelConstraints[]\n): Layout {\n  let explicitCount = 0;\n  let total = 0;\n\n  const layout: Layout = {};\n\n  for (const current of derivedPanelConstraints) {\n    if (current.defaultSize !== undefined) {\n      explicitCount++;\n\n      const size = formatLayoutNumber(current.defaultSize);\n\n      total += size;\n      layout[current.panelId] = size;\n    } else {\n      // @ts-expect-error Add panel keys in order to simplify traversal elsewhere; we'll fill them in in the loop below\n      layout[current.panelId] = undefined;\n    }\n  }\n\n  const remainingPanelCount = derivedPanelConstraints.length - explicitCount;\n  if (remainingPanelCount !== 0) {\n    const size = formatLayoutNumber((100 - total) / remainingPanelCount);\n\n    for (const current of derivedPanelConstraints) {\n      if (current.defaultSize === undefined) {\n        layout[current.panelId] = size;\n      }\n    }\n  }\n\n  return layout;\n}\n","import type { RegisteredGroup } from \"../../components/group/types\";\nimport { calculateAvailableGroupSize } from \"../dom/calculateAvailableGroupSize\";\nimport { formatLayoutNumber } from \"./formatLayoutNumber\";\n\nexport function notifyPanelOnResize(\n  group: RegisteredGroup,\n  element: HTMLElement,\n  borderBoxSize: readonly ResizeObserverSize[]\n) {\n  const resizeObserverSize = borderBoxSize[0];\n  if (!resizeObserverSize) {\n    return;\n  }\n\n  const panel = group.panels.find((current) => current.element === element);\n  if (!panel || !panel.onResize) {\n    return;\n  }\n\n  const groupSize = calculateAvailableGroupSize({ group });\n\n  const panelSize =\n    group.orientation === \"horizontal\"\n      ? panel.element.offsetWidth\n      : panel.element.offsetHeight;\n\n  const prevSize = panel.mutableValues.prevSize;\n  const nextSize = {\n    asPercentage: formatLayoutNumber((panelSize / groupSize) * 100),\n    inPixels: panelSize\n  };\n  panel.mutableValues.prevSize = nextSize;\n\n  panel.onResize(nextSize, panel.id, prevSize);\n}\n","export function objectsEqual(a: object, b: object) {\n  const keys = Object.keys(a);\n  if (keys.length !== Object.keys(b).length) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key as keyof typeof a] !== b[key as keyof typeof b]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type { Layout } from \"../../components/group/types\";\nimport type { RegisteredPanel } from \"../../components/panel/types\";\n\nexport function validateLayoutKeys(panels: RegisteredPanel[], layout: Layout) {\n  const panelIds = panels.map((panel) => panel.id);\n  const layoutKeys = Object.keys(layout);\n\n  if (panelIds.length !== layoutKeys.length) {\n    return false;\n  }\n\n  for (const panelId of panelIds) {\n    if (!layoutKeys.includes(panelId)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type { Layout, RegisteredGroup } from \"../components/group/types\";\nimport { assert } from \"../utils/assert\";\nimport { calculateAvailableGroupSize } from \"./dom/calculateAvailableGroupSize\";\nimport { calculateHitRegions } from \"./dom/calculateHitRegions\";\nimport { calculatePanelConstraints } from \"./dom/calculatePanelConstraints\";\nimport { onDocumentDoubleClick } from \"./event-handlers/onDocumentDoubleClick\";\nimport { onDocumentKeyDown } from \"./event-handlers/onDocumentKeyDown\";\nimport { onDocumentPointerDown } from \"./event-handlers/onDocumentPointerDown\";\nimport { onDocumentPointerLeave } from \"./event-handlers/onDocumentPointerLeave\";\nimport { onDocumentPointerMove } from \"./event-handlers/onDocumentPointerMove\";\nimport { onDocumentPointerUp } from \"./event-handlers/onDocumentPointerUp\";\nimport { update, type SeparatorToPanelsMap } from \"./mutableState\";\nimport { calculateDefaultLayout } from \"./utils/calculateDefaultLayout\";\nimport { layoutsEqual } from \"./utils/layoutsEqual\";\nimport { notifyPanelOnResize } from \"./utils/notifyPanelOnResize\";\nimport { objectsEqual } from \"./utils/objectsEqual\";\nimport { validateLayoutKeys } from \"./utils/validateLayoutKeys\";\nimport { validatePanelGroupLayout } from \"./utils/validatePanelGroupLayout\";\n\nconst ownerDocumentReferenceCounts = new Map<Document, number>();\n\nexport function mountGroup(group: RegisteredGroup) {\n  let isMounted = true;\n\n  assert(\n    group.element.ownerDocument.defaultView,\n    \"Cannot register an unmounted Group\"\n  );\n\n  const ResizeObserver = group.element.ownerDocument.defaultView.ResizeObserver;\n\n  const panelIds = new Set<string>();\n  const separatorIds = new Set<string>();\n\n  // Add Panels with onResize callbacks to ResizeObserver\n  // Add Group to ResizeObserver also in order to sync % based constraints\n  const resizeObserver = new ResizeObserver((entries) => {\n    for (const entry of entries) {\n      const { borderBoxSize, target } = entry;\n      if (target === group.element) {\n        if (isMounted) {\n          const groupSize = calculateAvailableGroupSize({ group });\n          if (groupSize === 0) {\n            // Can't calculate anything meaningful if the group has a width/height of 0\n            // (This could indicate that it's within a hidden subtree)\n            return;\n          }\n\n          update((prevState) => {\n            const match = prevState.mountedGroups.get(group);\n            if (match) {\n              // Update non-percentage based constraints\n              const nextDerivedPanelConstraints =\n                calculatePanelConstraints(group);\n\n              // Revalidate layout in case constraints have changed\n              const prevLayout = match.defaultLayoutDeferred\n                ? calculateDefaultLayout(nextDerivedPanelConstraints)\n                : match.layout;\n              const nextLayout = validatePanelGroupLayout({\n                layout: prevLayout,\n                panelConstraints: nextDerivedPanelConstraints\n              });\n\n              if (\n                !match.defaultLayoutDeferred &&\n                layoutsEqual(prevLayout, nextLayout) &&\n                objectsEqual(\n                  match.derivedPanelConstraints,\n                  nextDerivedPanelConstraints\n                )\n              ) {\n                return prevState;\n              }\n\n              return {\n                mountedGroups: new Map(prevState.mountedGroups).set(group, {\n                  defaultLayoutDeferred: false,\n                  derivedPanelConstraints: nextDerivedPanelConstraints,\n                  layout: nextLayout,\n                  separatorToPanels: match.separatorToPanels\n                })\n              };\n            }\n\n            return prevState;\n          });\n        }\n      } else {\n        notifyPanelOnResize(group, target as HTMLElement, borderBoxSize);\n      }\n    }\n  });\n  resizeObserver.observe(group.element);\n  group.panels.forEach((panel) => {\n    assert(\n      !panelIds.has(panel.id),\n      `Panel ids must be unique; id \"${panel.id}\" was used more than once`\n    );\n\n    panelIds.add(panel.id);\n\n    if (panel.onResize) {\n      resizeObserver.observe(panel.element);\n    }\n  });\n\n  const groupSize = calculateAvailableGroupSize({ group });\n\n  // Calculate initial layout for the new Panel configuration\n  const derivedPanelConstraints = calculatePanelConstraints(group);\n  const panelIdsKey = group.panels.map(({ id }) => id).join(\",\");\n\n  // Gracefully handle an invalid default layout\n  // This could happen when e.g. useDefaultLayout is combined with dynamic Panels\n  // In this case the best we can do is ignore the incoming layout\n  let defaultLayout: Layout | undefined = group.defaultLayout;\n  if (defaultLayout) {\n    if (!validateLayoutKeys(group.panels, defaultLayout)) {\n      defaultLayout = undefined;\n    }\n  }\n\n  const defaultLayoutUnsafe: Layout =\n    group.inMemoryLayouts[panelIdsKey] ??\n    defaultLayout ??\n    calculateDefaultLayout(derivedPanelConstraints);\n  const defaultLayoutSafe = validatePanelGroupLayout({\n    layout: defaultLayoutUnsafe,\n    panelConstraints: derivedPanelConstraints\n  });\n\n  const hitRegions = calculateHitRegions(group);\n\n  const ownerDocument = group.element.ownerDocument;\n\n  update((prevState) => {\n    const separatorToPanels: SeparatorToPanelsMap = new Map();\n\n    ownerDocumentReferenceCounts.set(\n      ownerDocument,\n      (ownerDocumentReferenceCounts.get(ownerDocument) ?? 0) + 1\n    );\n\n    hitRegions.forEach((hitRegion) => {\n      if (hitRegion.separator) {\n        separatorToPanels.set(hitRegion.separator, hitRegion.panels);\n      }\n    });\n\n    return {\n      mountedGroups: new Map(prevState.mountedGroups).set(group, {\n        defaultLayoutDeferred: groupSize === 0,\n        derivedPanelConstraints,\n        layout: defaultLayoutSafe,\n        separatorToPanels\n      })\n    };\n  });\n\n  group.separators.forEach((separator) => {\n    assert(\n      !separatorIds.has(separator.id),\n      `Separator ids must be unique; id \"${separator.id}\" was used more than once`\n    );\n\n    separatorIds.add(separator.id);\n\n    separator.element.addEventListener(\"keydown\", onDocumentKeyDown);\n  });\n\n  // If this is the first group to be mounted, initialize event handlers\n  if (ownerDocumentReferenceCounts.get(ownerDocument) === 1) {\n    ownerDocument.addEventListener(\"dblclick\", onDocumentDoubleClick, true);\n    ownerDocument.addEventListener(\"pointerdown\", onDocumentPointerDown, true);\n    ownerDocument.addEventListener(\"pointerleave\", onDocumentPointerLeave);\n    ownerDocument.addEventListener(\"pointermove\", onDocumentPointerMove);\n    ownerDocument.addEventListener(\"pointerup\", onDocumentPointerUp, true);\n  }\n\n  return function unmountGroup() {\n    isMounted = false;\n\n    ownerDocumentReferenceCounts.set(\n      ownerDocument,\n      Math.max(0, (ownerDocumentReferenceCounts.get(ownerDocument) ?? 0) - 1)\n    );\n\n    update((prevState) => {\n      const mountedGroups = new Map(prevState.mountedGroups);\n      mountedGroups.delete(group);\n\n      return { mountedGroups };\n    });\n\n    group.separators.forEach((separator) => {\n      separator.element.removeEventListener(\"keydown\", onDocumentKeyDown);\n    });\n\n    // If this was the last group to be mounted, tear down event handlers\n    if (!ownerDocumentReferenceCounts.get(ownerDocument)) {\n      ownerDocument.removeEventListener(\n        \"dblclick\",\n        onDocumentDoubleClick,\n        true\n      );\n      ownerDocument.removeEventListener(\n        \"pointerdown\",\n        onDocumentPointerDown,\n        true\n      );\n      ownerDocument.removeEventListener(\"pointerleave\", onDocumentPointerLeave);\n      ownerDocument.removeEventListener(\"pointermove\", onDocumentPointerMove);\n      ownerDocument.removeEventListener(\"pointerup\", onDocumentPointerUp, true);\n    }\n\n    resizeObserver.disconnect();\n  };\n}\n","import { useCallback, useState } from \"react\";\n\nexport function useForceUpdate() {\n  const [sigil, setSigil] = useState({});\n\n  const forceUpdate = useCallback(() => setSigil({}), []);\n\n  return [sigil as unknown, forceUpdate] as const;\n}\n","import { useId as useIdReact } from \"react\";\n\nexport function useId(stableId: number | string | undefined) {\n  const dynamicId = useIdReact();\n\n  return `${stableId ?? dynamicId}`;\n}\n","import { useEffect, useLayoutEffect } from \"react\";\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n","import { useCallback, useRef } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\n\n// Forked from useEventCallback (usehooks-ts)\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nexport function useStableCallback<Callback extends Function>(\n  fn: Callback\n): Callback {\n  const ref = useRef<Callback>(fn);\n\n  useIsomorphicLayoutEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n\n  return useCallback(\n    (...args: unknown[]) => ref.current?.(...args),\n    [ref]\n  ) as unknown as Callback;\n}\n","import { type Ref } from \"react\";\nimport { useStableCallback } from \"./useStableCallback\";\n\ntype PossibleRef<Type> = Ref<Type> | undefined;\n\nexport function useMergedRefs<Type>(...refs: PossibleRef<Type>[]) {\n  return useStableCallback((value: Type | null) => {\n    refs.forEach((ref) => {\n      if (ref) {\n        switch (typeof ref) {\n          case \"function\": {\n            ref(value);\n            break;\n          }\n          case \"object\": {\n            ref.current = value;\n            break;\n          }\n        }\n      }\n    });\n  });\n}\n","import { useRef } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\n\nexport function useStableObject<Type extends object>(\n  unstableObject: Type\n): Type {\n  const ref = useRef<Type>({ ...unstableObject });\n\n  useIsomorphicLayoutEffect(() => {\n    for (const key in unstableObject) {\n      ref.current[key] = unstableObject[key];\n    }\n  }, [unstableObject]);\n\n  return ref.current;\n}\n","import { createContext } from \"react\";\nimport type { GroupContextType } from \"./types\";\n\nexport const GroupContext = createContext<GroupContextType | null>(null);\n","import { useImperativeHandle, useRef, type Ref } from \"react\";\nimport { IDENTITY_FUNCTION } from \"../../constants\";\nimport { getImperativeGroupMethods } from \"../../global/utils/getImperativeGroupMethods\";\nimport { useIsomorphicLayoutEffect } from \"../../hooks/useIsomorphicLayoutEffect\";\nimport type { GroupImperativeHandle } from \"./types\";\n\nexport function useGroupImperativeHandle(\n  groupId: string,\n  groupRef: Ref<GroupImperativeHandle> | undefined\n) {\n  const imperativeGroupRef = useRef<GroupImperativeHandle>({\n    getLayout: () => ({}),\n    setLayout: IDENTITY_FUNCTION\n  });\n\n  useImperativeHandle(groupRef, () => imperativeGroupRef.current, []);\n\n  useIsomorphicLayoutEffect(() => {\n    Object.assign(\n      imperativeGroupRef.current,\n      getImperativeGroupMethods({ groupId })\n    );\n  });\n}\n","\"use client\";\n\nimport { useEffect, useMemo, useRef, type CSSProperties } from \"react\";\nimport { mountGroup } from \"../../global/mountGroup\";\nimport { eventEmitter, read } from \"../../global/mutableState\";\nimport { layoutsEqual } from \"../../global/utils/layoutsEqual\";\nimport { useForceUpdate } from \"../../hooks/useForceUpdate\";\nimport { useId } from \"../../hooks/useId\";\nimport { useIsomorphicLayoutEffect } from \"../../hooks/useIsomorphicLayoutEffect\";\nimport { useMergedRefs } from \"../../hooks/useMergedRefs\";\nimport { useStableCallback } from \"../../hooks/useStableCallback\";\nimport { useStableObject } from \"../../hooks/useStableObject\";\nimport type { RegisteredPanel } from \"../panel/types\";\nimport type { RegisteredSeparator } from \"../separator/types\";\nimport { GroupContext } from \"./GroupContext\";\nimport { sortByElementOffset } from \"./sortByElementOffset\";\nimport type { GroupProps, Layout, RegisteredGroup } from \"./types\";\nimport { useGroupImperativeHandle } from \"./useGroupImperativeHandle\";\n\n/**\n * A Group wraps a set of resizable Panel components.\n * Group content can be resized _horizontally_ or _vertically_.\n *\n * Group elements always include the following attributes:\n *\n * ```html\n * <div data-group data-testid=\"group-id-prop\" id=\"group-id-prop\">\n * ```\n *\n * ℹ️ [Test id](https://testing-library.com/docs/queries/bytestid/) can be used to narrow selection when unit testing.\n */\nexport function Group({\n  children,\n  className,\n  defaultLayout,\n  disableCursor,\n  disabled,\n  elementRef: elementRefProp,\n  groupRef,\n  id: idProp,\n  onLayoutChange: onLayoutChangeUnstable,\n  onLayoutChanged: onLayoutChangedUnstable,\n  orientation = \"horizontal\",\n  style,\n  ...rest\n}: GroupProps) {\n  const prevLayoutRef = useRef<{\n    onLayoutChange: Layout;\n    onLayoutChanged: Layout;\n  }>({\n    onLayoutChange: {},\n    onLayoutChanged: {}\n  });\n\n  const onLayoutChangeStable = useStableCallback((layout: Layout) => {\n    if (layoutsEqual(prevLayoutRef.current.onLayoutChange, layout)) {\n      // Memoize callback\n      return;\n    }\n\n    prevLayoutRef.current.onLayoutChange = layout;\n    onLayoutChangeUnstable?.(layout);\n  });\n\n  const onLayoutChangedStable = useStableCallback((layout: Layout) => {\n    if (layoutsEqual(prevLayoutRef.current.onLayoutChanged, layout)) {\n      // Memoize callback\n      return;\n    }\n\n    prevLayoutRef.current.onLayoutChanged = layout;\n    onLayoutChangedUnstable?.(layout);\n  });\n\n  const id = useId(idProp);\n\n  const elementRef = useRef<HTMLDivElement | null>(null);\n\n  const [panelOrSeparatorChangeSigil, forceUpdate] = useForceUpdate();\n\n  const inMemoryValuesRef = useRef<{\n    lastExpandedPanelSizes: { [panelIds: string]: number };\n    layouts: { [panelIds: string]: Layout };\n    panels: RegisteredPanel[];\n    separators: RegisteredSeparator[];\n  }>({\n    lastExpandedPanelSizes: {},\n    layouts: {},\n    panels: [],\n    separators: []\n  });\n\n  const mergedRef = useMergedRefs(elementRef, elementRefProp);\n\n  useGroupImperativeHandle(id, groupRef);\n\n  // TRICKY Don't read for state; it will always lag behind by one tick\n  const getPanelStyles = useStableCallback(\n    (groupId: string, panelId: string) => {\n      const { interactionState, mountedGroups } = read();\n\n      for (const group of mountedGroups.keys()) {\n        if (group.id === groupId) {\n          const match = mountedGroups.get(group);\n          if (match) {\n            let dragActive = false;\n            switch (interactionState.state) {\n              case \"active\": {\n                dragActive = interactionState.hitRegions.some(\n                  (current) => current.group === group\n                );\n                break;\n              }\n            }\n\n            return {\n              flexGrow: match.layout[panelId] ?? 1,\n              pointerEvents: dragActive ? \"none\" : undefined\n            } satisfies CSSProperties;\n          }\n        }\n      }\n\n      // This is unexpected except for the initial mount (before the group has registered with the global store)\n      return {\n        flexGrow: defaultLayout?.[panelId] ?? 1\n      } satisfies CSSProperties;\n    }\n  );\n\n  const context = useMemo(\n    () => ({\n      getPanelStyles,\n      id,\n      orientation,\n      registerPanel: (panel: RegisteredPanel) => {\n        const inMemoryValues = inMemoryValuesRef.current;\n        inMemoryValues.panels = sortByElementOffset(orientation, [\n          ...inMemoryValues.panels,\n          panel\n        ]);\n\n        forceUpdate();\n\n        return () => {\n          inMemoryValues.panels = inMemoryValues.panels.filter(\n            (current) => current !== panel\n          );\n\n          forceUpdate();\n        };\n      },\n      registerSeparator: (separator: RegisteredSeparator) => {\n        const inMemoryValues = inMemoryValuesRef.current;\n        inMemoryValues.separators = sortByElementOffset(orientation, [\n          ...inMemoryValues.separators,\n          separator\n        ]);\n\n        forceUpdate();\n\n        return () => {\n          inMemoryValues.separators = inMemoryValues.separators.filter(\n            (current) => current !== separator\n          );\n\n          forceUpdate();\n        };\n      }\n    }),\n    [getPanelStyles, id, forceUpdate, orientation]\n  );\n\n  const stableProps = useStableObject({\n    defaultLayout,\n    disableCursor\n  });\n\n  const registeredGroupRef = useRef<RegisteredGroup | null>(null);\n\n  // Register Group and child Panels/Separators with global state\n  // Listen to global state for drag state related to this Group\n  useIsomorphicLayoutEffect(() => {\n    const element = elementRef.current;\n    if (element === null) {\n      return;\n    }\n\n    const inMemoryValues = inMemoryValuesRef.current;\n\n    const group: RegisteredGroup = {\n      defaultLayout: stableProps.defaultLayout,\n      disableCursor: !!stableProps.disableCursor,\n      disabled: !!disabled,\n      element,\n      id,\n      inMemoryLastExpandedPanelSizes:\n        inMemoryValuesRef.current.lastExpandedPanelSizes,\n      inMemoryLayouts: inMemoryValuesRef.current.layouts,\n      orientation,\n      panels: inMemoryValues.panels,\n      separators: inMemoryValues.separators\n    };\n\n    registeredGroupRef.current = group;\n\n    const unmountGroup = mountGroup(group);\n\n    const globalState = read();\n    const match = globalState.mountedGroups.get(group);\n    if (match) {\n      const { defaultLayoutDeferred, derivedPanelConstraints, layout } = match;\n\n      if (!defaultLayoutDeferred && derivedPanelConstraints.length > 0) {\n        onLayoutChangeStable(layout);\n        onLayoutChangedStable(layout);\n\n        inMemoryValues.panels.forEach((panel) => {\n          panel.scheduleUpdate();\n        });\n      }\n    }\n\n    const removeInteractionStateChangeListener = eventEmitter.addListener(\n      \"interactionStateChange\",\n      () => {\n        inMemoryValues.panels.forEach((panel) => {\n          panel.scheduleUpdate();\n        });\n      }\n    );\n\n    const removeMountedGroupsChangeEventListener = eventEmitter.addListener(\n      \"mountedGroupsChange\",\n      (mountedGroups) => {\n        const match = mountedGroups.get(group);\n        if (match) {\n          const { defaultLayoutDeferred, derivedPanelConstraints, layout } =\n            match;\n\n          if (defaultLayoutDeferred || derivedPanelConstraints.length === 0) {\n            // This indicates that the Group has not finished mounting yet\n            // Likely because it has been rendered inside of a hidden DOM subtree\n            // Ignore layouts in this case because they will not have been validated\n            return;\n          }\n\n          const { interactionState } = read();\n          const isCompleted = interactionState.state !== \"active\";\n\n          onLayoutChangeStable(layout);\n          if (isCompleted) {\n            onLayoutChangedStable(layout);\n          }\n\n          inMemoryValues.panels.forEach((panel) => {\n            panel.scheduleUpdate();\n          });\n        }\n      }\n    );\n\n    return () => {\n      registeredGroupRef.current = null;\n\n      unmountGroup();\n      removeInteractionStateChangeListener();\n      removeMountedGroupsChangeEventListener();\n    };\n  }, [\n    disabled,\n    id,\n    onLayoutChangedStable,\n    onLayoutChangeStable,\n    orientation,\n    panelOrSeparatorChangeSigil,\n    stableProps\n  ]);\n\n  // Not all props require re-registering the group;\n  // Some can be updated after the group has been registered\n  useEffect(() => {\n    const registeredGroup = registeredGroupRef.current;\n    if (registeredGroup) {\n      registeredGroup.defaultLayout = defaultLayout;\n      registeredGroup.disableCursor = !!disableCursor;\n    }\n  });\n\n  return (\n    <GroupContext.Provider value={context}>\n      <div\n        {...rest}\n        aria-orientation={orientation}\n        className={className}\n        data-group\n        data-testid={id}\n        id={id}\n        ref={mergedRef}\n        style={{\n          height: \"100%\",\n          width: \"100%\",\n          overflow: \"hidden\",\n          ...style,\n          display: \"flex\",\n          flexDirection: orientation === \"horizontal\" ? \"row\" : \"column\",\n          flexWrap: \"nowrap\"\n        }}\n      >\n        {children}\n      </div>\n    </GroupContext.Provider>\n  );\n}\n\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName\nGroup.displayName = \"Group\";\n","export function getStorageKey(id: string, panelIds: string[]): string {\n  return `react-resizable-panels:${[id, ...panelIds].join(\":\")}`;\n}\n","import {\n  useCallback,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useSyncExternalStore\n} from \"react\";\nimport { getStorageKey } from \"./auto-save/getStorageKey\";\nimport type {\n  Layout,\n  LayoutStorage,\n  OnGroupLayoutChange,\n  OnGroupLayoutChanged\n} from \"./types\";\n\n/**\n * Saves and restores group layouts between page loads.\n * It can be configured to store values using `localStorage`, `sessionStorage`, cookies, or any other persistence layer that makes sense for your application.\n */\nexport function useDefaultLayout({\n  debounceSaveMs = 100,\n  panelIds,\n  storage = localStorage,\n  ...rest\n}: {\n  /**\n   * Debounce save operation by the specified number of milliseconds; defaults to 100ms\n   *\n   * @deprecated Use the {@link onLayoutChanged} callback instead; it does not require debouncing\n   */\n  debounceSaveMs?: number;\n\n  /**\n   * For Groups that contain conditionally-rendered Panels, this prop can be used to save and restore multiple layouts.\n   *\n   * ℹ️ This prevents layout shift for server-rendered apps.\n   *\n   * ⚠️ Panel ids must match the Panels rendered within the Group during mount or the initial layout will be incorrect.\n   */\n  panelIds?: string[] | undefined;\n\n  /**\n   * Storage implementation; supports localStorage, sessionStorage, and custom implementations\n   * Refer to documentation site for example integrations.\n   *\n   */\n  storage?: LayoutStorage;\n} & (\n  | {\n      /**\n       * Group id; must be unique in order for layouts to be saved separately.\n       * @deprecated Use the {@link id} param instead\n       */\n      groupId: string;\n    }\n  | {\n      /**\n       * Uniquely identifies a specific group/layout.\n       */\n      id: string;\n    }\n)) {\n  const hasPanelIds = panelIds !== undefined;\n  const id = \"id\" in rest ? rest.id : rest.groupId;\n\n  const readStorageKey = getStorageKey(id, panelIds ?? []);\n\n  // In the event that a client-only storage API is provided,\n  // useSyncExternalStore prevents server/client hydration mismatch warning\n  // This is not ideal; if possible a server-friendly storage API should be used\n  const defaultLayoutString = useSyncExternalStore(\n    subscribe,\n    () => storage.getItem(readStorageKey),\n    () => storage.getItem(readStorageKey)\n  );\n\n  const defaultLayout = useMemo(\n    () =>\n      defaultLayoutString\n        ? (JSON.parse(defaultLayoutString) as Layout)\n        : undefined,\n    [defaultLayoutString]\n  );\n\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  const clearPendingTimeout = useCallback(() => {\n    const timeout = timeoutRef.current;\n    if (timeout) {\n      timeoutRef.current = null;\n\n      clearTimeout(timeout);\n    }\n  }, []);\n\n  useLayoutEffect(() => {\n    return () => {\n      clearPendingTimeout();\n    };\n  }, [clearPendingTimeout]);\n\n  const onLayoutChanged = useCallback<NonNullable<OnGroupLayoutChanged>>(\n    (layout: Layout) => {\n      clearPendingTimeout();\n\n      let writeStorageKey: string;\n      if (hasPanelIds) {\n        writeStorageKey = getStorageKey(id, Object.keys(layout));\n      } else {\n        writeStorageKey = getStorageKey(id, []);\n      }\n\n      try {\n        storage.setItem(writeStorageKey, JSON.stringify(layout));\n      } catch (error) {\n        console.error(error);\n      }\n    },\n    [clearPendingTimeout, hasPanelIds, id, storage]\n  );\n\n  // TODO Deprecated; remove this in the future release\n  const onLayoutChange = useCallback<NonNullable<OnGroupLayoutChange>>(\n    (layout: Layout) => {\n      clearPendingTimeout();\n\n      if (debounceSaveMs === 0) {\n        onLayoutChanged(layout);\n      } else {\n        timeoutRef.current = setTimeout(() => {\n          onLayoutChanged(layout);\n        }, debounceSaveMs);\n      }\n    },\n    [clearPendingTimeout, debounceSaveMs, onLayoutChanged]\n  );\n\n  return {\n    /**\n     * Pass this value to `Group` as the `defaultLayout` prop.\n     */\n    defaultLayout,\n\n    /**\n     * Attach this callback on the `Group` as the `onLayoutChange` prop.\n     *\n     * @deprecated Use the {@link onLayoutChanged} prop instead.\n     */\n    onLayoutChange,\n\n    /**\n     * Attach this callback on the `Group` as the `onLayoutChanged` prop.\n     */\n    onLayoutChanged\n  };\n}\n\nfunction subscribe() {\n  return function unsubscribe() {};\n}\n","import { useState } from \"react\";\nimport type { GroupImperativeHandle } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref callback for the Group component.\n *\n * Use this hook when you need to share the ref with another component or hook.\n */\nexport function useGroupCallbackRef() {\n  return useState<GroupImperativeHandle | null>(null);\n}\n","import { useRef } from \"react\";\nimport type { GroupImperativeHandle } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref for the Group component.\n */\nexport function useGroupRef() {\n  return useRef<GroupImperativeHandle | null>(null);\n}\n","import { useContext } from \"react\";\nimport { assert } from \"../../utils/assert\";\nimport { GroupContext } from \"./GroupContext\";\n\nexport function useGroupContext() {\n  const context = useContext(GroupContext);\n  assert(\n    context,\n    \"Group Context not found; did you render a Panel or Separator outside of a Group?\"\n  );\n\n  return context;\n}\n","import { useImperativeHandle, useRef, type Ref } from \"react\";\nimport { NOOP_FUNCTION } from \"../../constants\";\nimport { getImperativePanelMethods } from \"../../global/utils/getImperativePanelMethods\";\nimport { useIsomorphicLayoutEffect } from \"../../hooks/useIsomorphicLayoutEffect\";\nimport { useGroupContext } from \"../group/useGroupContext\";\nimport type { PanelImperativeHandle } from \"./types\";\n\nexport function usePanelImperativeHandle(\n  panelId: string,\n  panelRef: Ref<PanelImperativeHandle> | undefined\n) {\n  const { id: groupId } = useGroupContext();\n\n  const imperativePanelRef = useRef<PanelImperativeHandle>({\n    collapse: NOOP_FUNCTION,\n    expand: NOOP_FUNCTION,\n    getSize: () => ({\n      asPercentage: 0,\n      inPixels: 0\n    }),\n    isCollapsed: () => false,\n    resize: NOOP_FUNCTION\n  });\n\n  useImperativeHandle(panelRef, () => imperativePanelRef.current, []);\n\n  useIsomorphicLayoutEffect(() => {\n    Object.assign(\n      imperativePanelRef.current,\n      getImperativePanelMethods({ groupId, panelId })\n    );\n  });\n}\n","\"use client\";\n\nimport { useRef, type CSSProperties } from \"react\";\nimport { useForceUpdate } from \"../../hooks/useForceUpdate\";\nimport { useId } from \"../../hooks/useId\";\nimport { useIsomorphicLayoutEffect } from \"../../hooks/useIsomorphicLayoutEffect\";\nimport { useMergedRefs } from \"../../hooks/useMergedRefs\";\nimport { useStableCallback } from \"../../hooks/useStableCallback\";\nimport { useGroupContext } from \"../group/useGroupContext\";\nimport type { PanelProps, PanelSize } from \"./types\";\nimport { usePanelImperativeHandle } from \"./usePanelImperativeHandle\";\n\n/**\n * A Panel wraps resizable content and can be configured with min/max size constraints and collapsible behavior.\n *\n * Panel size props can be in the following formats:\n * - Percentage of the parent Group (0..100)\n * - Pixels\n * - Relative font units (em, rem)\n * - Viewport relative units (vh, vw)\n *\n * ℹ️ Numeric values are assumed to be pixels.\n * Strings without explicit units are assumed to be percentages (0%..100%).\n * Percentages may also be specified as strings ending with \"%\" (e.g. \"33%\")\n * Pixels may also be specified as strings ending with the unit \"px\".\n * Other units should be specified as strings ending with their CSS property units (e.g. 1rem, 50vh)\n *\n * Panel elements always include the following attributes:\n *\n * ```html\n * <div data-panel data-testid=\"panel-id-prop\" id=\"panel-id-prop\">\n * ```\n *\n * ℹ️ [Test id](https://testing-library.com/docs/queries/bytestid/) can be used to narrow selection when unit testing.\n *\n * ⚠️ Panel elements must be direct DOM children of their parent Group elements.\n */\nexport function Panel({\n  children,\n  className,\n  collapsedSize = \"0%\",\n  collapsible = false,\n  defaultSize,\n  elementRef: elementRefProp,\n  id: idProp,\n  maxSize = \"100%\",\n  minSize = \"0%\",\n  onResize: onResizeUnstable,\n  panelRef,\n  style,\n  ...rest\n}: PanelProps) {\n  const idIsStable = !!idProp;\n\n  const id = useId(idProp);\n\n  const elementRef = useRef<HTMLDivElement | null>(null);\n\n  const mergedRef = useMergedRefs(elementRef, elementRefProp);\n\n  const [, forceUpdate] = useForceUpdate();\n\n  const { getPanelStyles, id: groupId, registerPanel } = useGroupContext();\n\n  const hasOnResize = onResizeUnstable !== null;\n  const onResizeStable = useStableCallback(\n    (\n      panelSize: PanelSize,\n      _: string | number | undefined,\n      prevPanelSize: PanelSize | undefined\n    ) => {\n      onResizeUnstable?.(panelSize, idProp, prevPanelSize);\n    }\n  );\n\n  // Register Panel with parent Group\n  useIsomorphicLayoutEffect(() => {\n    const element = elementRef.current;\n    if (element !== null) {\n      return registerPanel({\n        element,\n        id,\n        idIsStable,\n        mutableValues: {\n          expandToSize: undefined,\n          prevSize: undefined\n        },\n        onResize: hasOnResize ? onResizeStable : undefined,\n        panelConstraints: {\n          collapsedSize,\n          collapsible,\n          defaultSize,\n          maxSize,\n          minSize\n        },\n        scheduleUpdate: forceUpdate\n      });\n    }\n  }, [\n    collapsedSize,\n    collapsible,\n    defaultSize,\n    forceUpdate,\n    hasOnResize,\n    id,\n    idIsStable,\n    maxSize,\n    minSize,\n    onResizeStable,\n    registerPanel\n  ]);\n\n  usePanelImperativeHandle(id, panelRef);\n\n  const panelStyles = getPanelStyles(groupId, id);\n\n  return (\n    <div\n      {...rest}\n      data-panel\n      data-testid={id}\n      id={id}\n      ref={mergedRef}\n      style={{\n        ...PROHIBITED_CSS_PROPERTIES,\n\n        display: \"flex\",\n        flexBasis: 0,\n        flexShrink: 1,\n\n        // Prevent Panel content from interfering with panel size\n        overflow: \"hidden\",\n\n        ...panelStyles\n      }}\n    >\n      <div\n        className={className}\n        style={{\n          flexGrow: 1,\n\n          ...style\n        }}\n      >\n        {children}\n      </div>\n    </div>\n  );\n}\n\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName\nPanel.displayName = \"Panel\";\n\nconst PROHIBITED_CSS_PROPERTIES: CSSProperties = {\n  minHeight: 0,\n  maxHeight: \"100%\",\n  height: \"auto\",\n\n  minWidth: 0,\n  maxWidth: \"100%\",\n  width: \"auto\",\n\n  border: \"none\",\n  borderWidth: 0,\n  padding: 0,\n  margin: 0\n};\n","import { useState } from \"react\";\nimport type { PanelImperativeHandle } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref callback for the Panel component.\n *\n * Use this hook when you need to share the ref with another component or hook.\n */\nexport function usePanelCallbackRef() {\n  return useState<PanelImperativeHandle | null>(null);\n}\n","import { useRef } from \"react\";\nimport type { PanelImperativeHandle } from \"./types\";\n\n/**\n * Convenience hook to return a properly typed ref for the Panel component.\n */\nexport function usePanelRef() {\n  return useRef<PanelImperativeHandle | null>(null);\n}\n","import type { Layout } from \"../../components/group/types\";\nimport type { PanelConstraints } from \"../../components/panel/types\";\nimport { adjustLayoutByDelta } from \"./adjustLayoutByDelta\";\nimport { validatePanelGroupLayout } from \"./validatePanelGroupLayout\";\n\nexport function calculateSeparatorAriaValues({\n  layout,\n  panelConstraints,\n  panelId,\n  panelIndex\n}: {\n  layout: Layout;\n  panelConstraints: PanelConstraints[];\n  panelId: string;\n  panelIndex: number;\n}): {\n  valueControls: string | undefined;\n  valueMax: number | undefined;\n  valueMin: number | undefined;\n  valueNow: number | undefined;\n} {\n  let valueMax: number | undefined = undefined;\n  let valueMin: number | undefined = undefined;\n\n  const panelSize = layout[panelId];\n\n  const constraints = panelConstraints.find(\n    (current) => current.panelId === panelId\n  );\n  if (constraints) {\n    const maxSize = constraints.maxSize;\n    const minSize = (valueMin = constraints.collapsible\n      ? constraints.collapsedSize\n      : constraints.minSize);\n\n    const pivotIndices = [panelIndex, panelIndex + 1];\n\n    const minSizeLayout = validatePanelGroupLayout({\n      layout: adjustLayoutByDelta({\n        delta: minSize - panelSize,\n        initialLayout: layout,\n        panelConstraints,\n        pivotIndices,\n        prevLayout: layout,\n        trigger: \"keyboard\"\n      }),\n      panelConstraints\n    });\n\n    valueMin = minSizeLayout[panelId];\n\n    const maxSizeLayout = validatePanelGroupLayout({\n      layout: adjustLayoutByDelta({\n        delta: maxSize - panelSize,\n        initialLayout: layout,\n        panelConstraints,\n        pivotIndices,\n        prevLayout: layout,\n        trigger: \"keyboard\"\n      }),\n      panelConstraints\n    });\n\n    valueMax = maxSizeLayout[panelId];\n  }\n\n  return {\n    valueControls: panelId,\n    valueMax,\n    valueMin,\n    valueNow: panelSize\n  };\n}\n","\"use client\";\n\nimport { useRef, useState } from \"react\";\nimport { eventEmitter } from \"../../global/mutableState\";\nimport type { InteractionState } from \"../../global/types\";\nimport { calculateSeparatorAriaValues } from \"../../global/utils/calculateSeparatorAriaValues\";\nimport { useId } from \"../../hooks/useId\";\nimport { useIsomorphicLayoutEffect } from \"../../hooks/useIsomorphicLayoutEffect\";\nimport { useMergedRefs } from \"../../hooks/useMergedRefs\";\nimport { useGroupContext } from \"../group/useGroupContext\";\nimport type { RegisteredSeparator, SeparatorProps } from \"./types\";\n\n/**\n * Separators are not _required_ but they are _recommended_ as they improve keyboard accessibility.\n *\n * ⚠️ Separator elements must be direct DOM children of their parent Group elements.\n *\n * Separator elements always include the following attributes:\n *\n * ```html\n * <div data-separator data-testid=\"separator-id-prop\" id=\"separator-id-prop\" role=\"separator\">\n * ```\n *\n * ℹ️ [Test id](https://testing-library.com/docs/queries/bytestid/) can be used to narrow selection when unit testing.\n *\n * ℹ️ In addition to the attributes shown above, separator also renders all required [WAI-ARIA properties](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Roles/separator_role#associated_wai-aria_roles_states_and_properties).\n */\nexport function Separator({\n  children,\n  className,\n  elementRef: elementRefProp,\n  id: idProp,\n  style,\n  ...rest\n}: SeparatorProps) {\n  const id = useId(idProp);\n\n  const [aria, setAria] = useState<{\n    valueControls?: string | undefined;\n    valueMin?: number | undefined;\n    valueMax?: number | undefined;\n    valueNow?: number | undefined;\n  }>({});\n\n  const [dragState, setDragState] =\n    useState<InteractionState[\"state\"]>(\"inactive\");\n\n  const elementRef = useRef<HTMLDivElement | null>(null);\n\n  const mergedRef = useMergedRefs(elementRef, elementRefProp);\n\n  const {\n    id: groupId,\n    orientation: groupOrientation,\n    registerSeparator\n  } = useGroupContext();\n\n  const orientation =\n    groupOrientation === \"horizontal\" ? \"vertical\" : \"horizontal\";\n\n  // Register Separator with parent Group\n  // Listen to global state for drag state related to this Separator\n  useIsomorphicLayoutEffect(() => {\n    const element = elementRef.current;\n    if (element !== null) {\n      const separator: RegisteredSeparator = {\n        element,\n        id\n      };\n\n      const unregisterSeparator = registerSeparator(separator);\n\n      const removeInteractionStateChangeListener = eventEmitter.addListener(\n        \"interactionStateChange\",\n        (interactionState) => {\n          setDragState(\n            interactionState.state !== \"inactive\" &&\n              interactionState.hitRegions.some(\n                (hitRegion) => hitRegion.separator === separator\n              )\n              ? interactionState.state\n              : \"inactive\"\n          );\n        }\n      );\n\n      const removeMountedGroupsChangeListener = eventEmitter.addListener(\n        \"mountedGroupsChange\",\n        (mountedGroups) => {\n          mountedGroups.forEach(\n            (\n              { derivedPanelConstraints, layout, separatorToPanels },\n              mountedGroup\n            ) => {\n              if (mountedGroup.id === groupId) {\n                const panels = separatorToPanels.get(separator);\n                if (panels) {\n                  const primaryPanel = panels[0];\n                  const panelIndex = mountedGroup.panels.indexOf(primaryPanel);\n\n                  setAria(\n                    calculateSeparatorAriaValues({\n                      layout,\n                      panelConstraints: derivedPanelConstraints,\n                      panelId: primaryPanel.id,\n                      panelIndex\n                    })\n                  );\n                }\n              }\n            }\n          );\n        }\n      );\n\n      return () => {\n        removeInteractionStateChangeListener();\n        removeMountedGroupsChangeListener();\n        unregisterSeparator();\n      };\n    }\n  }, [groupId, id, registerSeparator]);\n\n  return (\n    <div\n      {...rest}\n      aria-controls={aria.valueControls}\n      aria-orientation={orientation}\n      aria-valuemax={aria.valueMax}\n      aria-valuemin={aria.valueMin}\n      aria-valuenow={aria.valueNow}\n      children={children}\n      className={className}\n      data-separator={dragState}\n      data-testid={id}\n      id={id}\n      ref={mergedRef}\n      role=\"separator\"\n      style={{\n        flexBasis: \"auto\",\n        ...style,\n        flexGrow: 0,\n        flexShrink: 0\n      }}\n      tabIndex={0}\n    />\n  );\n}\n\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName\nSeparator.displayName = \"Separator\";\n"],"names":["assert","expectedCondition","message","calculateAvailableGroupSize","group","orientation","panels","totalSize","panel","sortByElementOffset","panelsOrSeparators","horizontalSort","verticalSort","a","b","delta","isHTMLElement","value","getDistanceBetweenPointAndRect","point","rect","findClosestRect","rects","targetRect","centerPoint","closestRect","minDistance","x","y","distance","cached","isCoarsePointer","calculateHitRegions","groupElement","separators","sortedChildElements","element","hitRegions","hasInterleavedStaticContent","prevPanel","pendingSeparators","childElement","panelData","current","prevRect","pendingRectsOrSeparators","firstPanelEdgeRect","secondPanelEdgeRect","separator","rectOrSeparator","minHitTargetSize","separatorData","convertEmToPixels","style","fontSize","convertRemToPixels","convertVhToPixels","convertVwToPixels","parseSizeAndUnit","size","numeric","sizeStyleToPixels","groupSize","panelElement","styleProp","pixels","unit","formatLayoutNumber","number","calculatePanelConstraints","panelConstraints","collapsedSize","defaultSize","minSize","maxSize","EventEmitter","#listenerMap","type","listener","listeners","data","didThrow","caughtError","clonedListeners","error","index","layoutNumbersEqual","actual","expected","minimumDelta","state","eventEmitter","read","update","partialState","prevState","constraints","prevLayout","isCollapsed","wasCollapsed","findClosestHitRegion","closestHitRegion","hitRegion","isShadowRoot","compare","ancestors","get_ancestors","common_ancestor","z_indexes","get_z_index","find_stacking_context","children","furthest_ancestors","child","props","is_flex_item","node","display","get_parent","creates_stacking_context","nodes","i","parentNode","doRectsIntersect","isViableHitTarget","pointerEventTarget","currentElement","findMatchingHitRegions","event","mountedGroups","matchingHitRegions","_","groupData","match","isArrayEqual","compareLayoutNumbers","validatePanelSize","collapsible","halfwayPoint","adjustLayoutByDelta","initialLayoutProp","panelConstraintsArray","pivotIndices","prevLayoutProp","trigger","initialLayout","nextLayout","firstPivotIndex","secondPivotIndex","deltaApplied","prevSize","localDelta","increment","maxAvailableDelta","minAbsDelta","deltaRemaining","unsafeSize","safeSize","pivotIndex","total","prevLayoutKeys","accumulated","layoutsEqual","id","validatePanelGroupLayout","layout","nextLayoutTotalSize","remainingSize","getImperativePanelMethods","groupId","panelId","find","defaultLayoutDeferred","derivedPanelConstraints","separatorToPanels","getPanelConstraints","getPanel","getPanelSize","setPanelSize","nextSize","isLastPanel","unsafeLayout","mutableValues","asPercentage","inPixels","onDocumentDoubleClick","groups","panelWithDefaultSize","api","findSeparatorGroup","separatorElement","getImperativeGroupMethods","getMountedGroup","mountedGroup","adjustLayoutForSeparator","onDocumentKeyDown","primaryPanel","separatorElements","nextIndex","onDocumentPointerDown","initialLayoutMap","didChangeFocus","IDENTITY_FUNCTION","NOOP_FUNCTION","CURSOR_FLAG_HORIZONTAL_MIN","CURSOR_FLAG_HORIZONTAL_MAX","CURSOR_FLAG_VERTICAL_MIN","CURSOR_FLAG_VERTICAL_MAX","CURSOR_FLAGS_HORIZONTAL","CURSOR_FLAGS_VERTICAL","supportsAdvancedCursorStyles","getCursorStyle","cursorFlags","horizontalCount","verticalCount","horizontalMin","horizontalMax","verticalMin","verticalMax","documentToStyleMap","updateCursorStyle","ownerDocument","prevStyle","styleSheet","interactionState","cursorStyle","nextStyle","updateActiveHitRegions","document","pointerDownAtPoint","prevCursorFlags","nextCursorFlags","nextMountedGroups","disableCursor","deltaAsPercentage","panelIdsKey","onDocumentPointerLeave","onDocumentPointerMove","onDocumentPointerUp","calculateDefaultLayout","explicitCount","remainingPanelCount","notifyPanelOnResize","borderBoxSize","panelSize","objectsEqual","key","validateLayoutKeys","panelIds","layoutKeys","ownerDocumentReferenceCounts","mountGroup","isMounted","ResizeObserver","separatorIds","resizeObserver","entries","entry","target","nextDerivedPanelConstraints","defaultLayout","defaultLayoutUnsafe","defaultLayoutSafe","useForceUpdate","sigil","setSigil","useState","forceUpdate","useCallback","useId","stableId","dynamicId","useIdReact","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","useStableCallback","fn","ref","useRef","args","useMergedRefs","refs","useStableObject","unstableObject","GroupContext","createContext","useGroupImperativeHandle","groupRef","imperativeGroupRef","useImperativeHandle","Group","className","disabled","elementRefProp","idProp","onLayoutChangeUnstable","onLayoutChangedUnstable","rest","prevLayoutRef","onLayoutChangeStable","onLayoutChangedStable","elementRef","panelOrSeparatorChangeSigil","inMemoryValuesRef","mergedRef","getPanelStyles","dragActive","context","useMemo","inMemoryValues","stableProps","registeredGroupRef","unmountGroup","removeInteractionStateChangeListener","removeMountedGroupsChangeEventListener","isCompleted","registeredGroup","jsx","getStorageKey","useDefaultLayout","debounceSaveMs","storage","hasPanelIds","readStorageKey","defaultLayoutString","useSyncExternalStore","subscribe","timeoutRef","clearPendingTimeout","timeout","onLayoutChanged","writeStorageKey","onLayoutChange","useGroupCallbackRef","useGroupRef","useGroupContext","useContext","usePanelImperativeHandle","panelRef","imperativePanelRef","Panel","onResizeUnstable","idIsStable","registerPanel","hasOnResize","onResizeStable","prevPanelSize","panelStyles","PROHIBITED_CSS_PROPERTIES","usePanelCallbackRef","usePanelRef","calculateSeparatorAriaValues","panelIndex","valueMax","valueMin","Separator","aria","setAria","dragState","setDragState","groupOrientation","registerSeparator","unregisterSeparator","removeMountedGroupsChangeListener"],"mappings":"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"}